<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>js+jq</title>
    <style>
        p {
            width: 100%;
        }
    </style>
</head>
<body>
<div><h2>第一天</h2>
    <h4>一、iconfont的使用：</h4>
    <p>作用：为了能够在页面上不再使用小图，将小图的内容直接用文本来表示以此来提前用户体验。</p>
    <ul>
        <li>百度搜索iconfont进入iconfont官网</li>
        <li>选择官网中的“图标库”--->“官方图标库”</li>
        <li>选择自己需要的字体库，点击进入，选择自己需要的字体，加入到购物车</li>
        <li>4）选择完成以后，点击购物车，选择下载代码</li>
        <li>5）进入下载的文件夹中，找到三个.html页面中的demo_fontclass.html，按照页面上的指示使用字体图标。</li>
    </ul>
    <h4>二丶其它属性的学习：</h4>
    <ul>
        <li>box-shadow: 0px 0px 10px #888888;</li>
        <li>设置阴影：左右平移 垂直平移 模糊程度 阴影颜色</li>
        <li>border-radius: 25px;</li>
        <li>placeholder:””;该属性设置默认文字</li>
        <li>w设置三角形：
            类名:after {
            content:””;
            height:0;
            width:0;
            line-height:0;
            border-width:5px;
            border-style: solid;
            border-color: transparent transparent blue;
        </li>
    </ul>
</div>
<div>
    <h2>第二天</h2>
    <ul>
        <li>块级元素水平集中：margin:0 auto等于 margin-left:auto+margin-right:auto</li>
    </ul>
</div>
<div>
    <h2>第三天</h2>
    <ul>
        <li>input系列之button按钮边框的宽度会占据内容部分，不会撑大盒子</li>
        <li>行内元素过长自动隐藏加省略号
            <p>
                a {
                width: 130px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                display: inline-block;
                }
            </p>
        </li>
    </ul>
</div>
<div>
    <h2>第四天复习js</h2>
    <h4>js的组成部分</h4>
    <ul>
        <li>1 ECMAScript js的基础语法规范</li>
        <li>2 DOM - 文档对象模型 document object model</li>
        <li>3 BOM - 浏览器对象模型 browser object model</li>
    </ul>
    <h4>浏览器的几个重要组成部分</h4>
    <ul>
        <li>1 用户界面</li>
        <li>2 浏览器引擎 - 中控</li>
        <li> 3 渲染引擎 -解析html和css代码 ：
            <ul>
                <li> 1 解析html代码：生成树模型</li>
                <li> 2 解析css代码：生成样式树</li>
                <li> 3 将样式树和树模型结合，生成渲染树（准备将页面效果显示出来）</li>
                <li> 4 根据渲染树上的每个部分，将真正的内容渲染在页面中</li>
            </ul>

        </li>
        <li>
            4 js解析器 ： 用于执行js代码
        </li>
    </ul>
    <h4>变量的作用：存储数据</h4>
    <p>数据的分类： 固定数据 临时数据;固定数据保存在硬盘中 临时数据保存在内存中</p>
    <h4>WebStorm快捷键</h4>
    <ul>
        <li>复制一行 ctrl + c</li>
        <li>复制一行到下一行 ctrl + d</li>
        <li>shift + enter回车 可以在下面快速创建一个新行</li>
        <li>格式化代码 ctrl + alt + l</li>
        <li>end键 可以跳到本行最后</li>
        <li>home键 可以跳到本行最前面</li>
        <li>ctrl表示按词跳跃</li>
        <li>shift表示选中</li>
    </ul>
    <h4>5大基本数据类型：</h4>
    <p>string number boolean null undefined</p>
    <p>typeof 用于对基本数据类型进行类型检测；用法两种：typeof 数据 typeof(数据)</p>
    <p>Infinity 无穷大（正无穷）;特殊值：NaN not a number 表示不是数值;
        js可以表示的最大值:Number.MAX_VALUE;js可以表示的最小正数:Number.MIN_VALUE
    </p>
    <p>null使用typeof结果为object，是不准确的，不能说明他是对象</p>
    <h4>类型转换</h4>
    <ul>
        <li>null 与undefined 没有对应的转换方式</li>
        <li>将其他类型转换为字符串类型：
            <ul>
                <li> 强制转换：数据.toString();String(数据)</li>
                <li>原因是null和undefined不具备toString方法</li>
                <li>隐式转换：使用任意数据类型 + 任意字符串，可以转换为字符串类型</li>

            </ul>
        </li>
        <li>将其他数据类型转换为数值类型：
            <ul>
                <li>强制转换:Number(数据)</li>
                <li>Number转换字符串时,如果字符串中含有字符，会转换失败，结果为NaN</li>
                <li>parseInt() 取出的数值为正数</li>
                <li>从左往右取，遇到不是数值为止，如果第一个字符就不是数值，转换失败，结果为NaN</li>
                <li>parseFloat(); 取出的数值可以包含小数;100.00这种数据的小数位没有意义，取出的值为100</li>
                <li>隐式转换：- * / %</li>
            </ul>
        </li>
        <li>将其他数据类型转换为boolean（布尔类型）
            <ul>
                <li>强制转换 Boolean(数据):能够转换为false的只有：false 0 "" NaN null undefined</li>
                <li>隐式转换 !!数据;console.log(!!null);</li>
            </ul>
        </li>

    </ul>

    <h4>运算符</h4>
    <p>== 相等比較，值等即可,!= 不相等 ，跟==对应; === 全等比較，比較值和类型,!== 不全等 ，跟===对应</p>
    <p>NaN 与任意类型判断==均为false</p>
    <p>isNaN(数据)如果数据值为NaN返回true，否则返回false</p>
    <ul>
        <li>当操作数不是bool值时：（短路操作）</li>
        <li>1 从左往右看</li>
        <li>2 如果操作数不是bool值，隐式转换</li>
        <li>3 哪个操作数可以决定式子结果，就返回这个源操作数</li>
        <li>4 如果第一个操作数无法决定结果，直接返回第二个操作数</li>
        <li>console.log(100 && 200);console.log(0 || 200);</li>
    </ul>
    <h4>结构语句,条件判断</h4>
    <p>switch 语句：如果条件中的基本值与某个case后的值全等，才会执行对应代码。</p>
    <p>使用switch进行范围的检测，需要在条件中书写true</p>
    <p>switch语句跟适用于单值的判断;if语句跟适用于范围的判断</p>
    <h5>优先级从高到低：</h5>
    <ul>
        <li>()</li>
        <li>一元运算符 ++ -- ! (+根据使用方式不同，优先级也不同)</li>
        <li>算数运算符 先* / % 后 + -</li>
        <li>比較 > < >= <= == === != !==</li>
        <li>逻辑运算符 && ||</li>
        <li>三元运算符 2>1?100:200;</li>
        <li>赋值运算符 = += -= *= /= %=</li>
    </ul>
    <h4>循环</h4>
    <ul>
        <li>for循环的适用场景：有规律有次数限制的重复执行代码</li>
        <li>使用while循环的适用场景：不确定循环次数重复执行代码</li>

    </ul>
    <h5>其他</h5>
    <p>当我们使用控制台调试时，注意的问题:1 不要在watch监视面板中监视可执行的代码;2 当我们需要查看一个变量的值时，最好使用watch，不要进行移入操作</p>
</div>
<div>
    <h2>第五天js循环和数组</h2>
    <h4>进制问题</h4>
    <ul>
        <li>2进制 逢2进1 01</li>
        <li>8进制 逢8进1 开头使用0进行表示 021</li>
        <li>16进制 逢16进1 0123456789 a b c d e f 0x21</li>
        <li>进制数表示当前是几进制，查看时从右往左看，左右侧的第一个位置位数为0</li>
        <li>当前位的数值 * 进制数^(位数-1)，多位之间进行结果相加</li>
        <li><p>
            把10进制转化为8进制：
            var num = 17;
            toString中转换一个数值参数表示要转换为几进制
            console.log(num.toString(8));8指的是转换后的进制
        </p></li>
        <li>
            <p>
                parseInt的第二个参数默认为10，表示当前数据为几进制，最终转换为10进制
                parseInt(数据,进制)
                var str = 21;
                console.log(parseInt(str, 8));8指的是转换后的进制
            </p>
        </li>
    </ul>
    <h4>循环</h4>
    <ul>
        <li> for的两种用法:
            1 获取一段有规律的数据
            2 有次数限制的重复执行代码
        </li>
        <li> 计算1-100之间的所有的质数
            <ul>
                <li> 质数：只能被1和自身整除</li>
                <li>能整除自己的数只存在与1-自身之间</li>
                <li>能整除自己的数<=Math.foolr(n/2)</li>
                <li>能整除自己的数<=Math.floor(Math.sqrt(n));</li>
            </ul>


        </li>
        <li>continue:结束本次循环，并且从下一次开始(顶部循环变量增减的位置)</li>
    </ul>
    <h4>数组</h4>
    <ul>
        <li>设置的值多余元素的个数:此种操作没有意义，不会添加新的数据;查看可能新增加的位置的值，值为undefined</li>
        <li>设置的值少于元素的个数:这时多余的元素会被删除</li>
        <li>清空数组:方式1:arr.length = 0;方式2：arr = [];console.log(arr);</li>
        <li>定义数组的两种方式(构造函数的方式，数组字面量的方式)
            var ary=new Array();var ary=[];
        </li>
        <li>数组.splice(索引,删除个数); //可以从数组中删除指定索引位置的数据</li>

    </ul>
    <h4>注意：</h4>
    <ul>
        <li> var arr = [1,2,3,4,5];
            console.log(arr);// 1,2,3,4,5
            arr[0] = 100;
            console.log(arr);// 100,2,3,4,5
        </li>
        <li>当上述代码在控制台打印时，结果与我们想的是一样的。</li>
        <li>但是如果将数组展开，这时控制台会重新读取对应数据的值，这时取值为新值</li>
    </ul>
</div>
<div>
    <h2>第六天数组，函数和作用域</h2>
    <h4>求数组类型的三种方式</h4>
    <ul>
        <li>Array.isArray(数组)，ie9一下浏览器不支持。ES5中提供的</li>
        <li>数组 instanceof Array，返回boolea值</li>
        <li>Object.prototype.toString.call(数组)，返回“[object Array]”字符串。推荐使用，可以访问任意的对象型数据的类型。</li>
        <li>二维数组及多位数组的应用：先判断数组的每个值，看是否有值为一个数组的，进行对应处理。（数组[i][j]）</li>
    </ul>
    <h4>基本数据类型和复杂数据类型的区别</h4>
    <ul>
        <li>保存数据的个数不同:基本类型保存一个值，复杂数据类型可以保存多个</li>
        <li>在内存中的保存方式不同：基本数据类型在内存单元中保存的是具体值，复杂数据类型在内存单元中保存的是具体值的指针</li>
        <li>基本数据类型和复杂数据类型在复制结果上不同:不同的原因是，复制操作复制的是变量指向的内存单元中的值</li>
        <li>null是基本数据类型;null代表了一个对象未初始化前的状态</li>
    </ul>
    <h4>函数</h4>
    <ul>
        <li>参数的使用场景： 当我们使用函数的时候，发现功能一定，内部的某些值不确定，可以给函数设置参数。</li>
        <li>参数的本质： 参数就相当于是函数内声明的一个变量</li>
        <li>形参的概念： 写在函数体中的参数称为形参，形参在使用时是没有值的，需要调用时传值。</li>
        <li>实参的概念： 形参值需要在使用时(调用函数),进行对应的传参，称为实参, 实参在函数调用的小括号中书写。</li>
        <li>如果函数没有设置返回值，默认为undefined</li>
        <li>函数调用表达式本身有两个作用：1 执行函数内部代码 2 本身代表了返回值</li>

    </ul>
    <h4>函数作用域及预解析变量和函数的提升方式</h4>
    <ul>
        <li>1 全局作用域：script内部并且不在任意函数内</li>
        <li>2 局部作用域：任意一个函数内部均为独立作用域,在js中有且仅有函数可以分割作用域(所以我们又将局部作用域称为函数作用域)</li>
        <li>3 全局变量：声明在全局作用域中的变量称为全局变量，在全局任意位置均可访问</li>
        <li>4 局部变量：声明在局部作用域中的变量称为局部变量，只能在声明这个变量的作用域内部使用</li>
        <li>5 查找当前作用域中的var变量声明语句，将变量声明语句提升到当前作用域顶端,赋值保留在原地</li>
        <li>6 查找当前作用域中的function函数声明语句,将函数体整体提升到当前作用域顶端,调用保留在原地</li>
        <li>js中函数不能重名，重名会使后者覆盖前者</li>
        <li>js中没有重载的概念</li>
    </ul>
    <h4>arguments模拟实现重载</h4>
    <ul>
        <li>arguments只能在函数内部使用</li>
        <li>arguments的数据结构具有索引，也具有长度，说明他是一个类数组结构(伪数组)伪数组就是没有数组方法的数组形式。</li>
        <li>实际上arguments就是当前这个函数的实参列表(内部保存了本次调用所传入的所有实参)</li>
        <li>可以利用arguments的length属性，进行判断，模拟函数重载的过程</li>

    </ul>
    <h4>函数补充</h4>
    <ul>
        <li>函数声明语句 function 函数名(){};2 函数表达式 ：将函数作为值保存在一个变量中进行使用,变量名就是函数名3.当一个函数没有名字，称为匿名函数</li>
        <li>函数表达式和函数声明语句的区别：预解析阶段的提升的规则不同，导致函数表达式无法在书写之前进行调用。函数表达式按照变量的声明方式，所以不会把方法体进行提升</li>
        <li>typeof 变量，可以判断变量是否是函数类型</li>
        <li>如果在操作参数时，如果实参值为复杂数据类型，在函数中直接修改时，实参也会对应改变</li>
        <li>函数没有声明但赋值了，预解析会默认声明到全局顶部</li>

    </ul>
    <h4>函数变量重名</h4>
    <ul>
        <li>有两个同名的函数，后者会覆盖前置。</li>
        <li>当函数和变量重名时，变量如果赋值了，因为变量是声明提升，而函数是整体提升，变量的值会覆盖函数；但变量没有赋值时，取函数值。因为空值不能覆盖有值的函数。</li>
    </ul>
</div>
<div>
    <h2>第七天对象和构造函数</h2>
    <p>将一个函数作为另一个函数的参数使用：整体功能一定，但是某些在不确定，传递一些数据参数即可；
        整体功能一定，但是内部某些子功能不确定，就需要将一些代码作为参数传递。再js中只有函数可以保存代码，传递的是函数体。
    </p>
    <ul>
        <li>函数也是一个数据类型，使用上和其他的数据没有本质区别</li>
        <li>可以使用匿名函数的方式，替代命名进行传参（减少函数名的占用）</li>
        <li>回调函数：把函数作为另一个函数的参数的行为称为回调函数。</li>
        <li>匿名函数：没有名字的函数。使用场景：
            1.保存再变量中作为函数表达式使用；
            2.作为参数传递使用（回调函数）
        </li>
        <li>
            自调用函数（逻辑执行函数）形式。执行方式：在书写的位置调用一次。
            作用：模拟块级作用域，减少全局变量的使用，提高性能，减少命名难度。
            语法：(function(){};)();
        </li>
        <li>块级作用域（了解）：js中没有块级作用域，有的只是函数内部的作用域；其他语言中，每个代码块的内部都是独立的作用域。</li>

    </ul>
    <h4>对象简介</h4>
    抽象和具体的关系：
    <ul>
        <li>抽象：生活中我们经常使用一些抽象的话来描述一些事物</li>
        <li>具体：当一个抽象的内容，内部所有特征确定后，变成了一个具体的事物</li>
        <li>抽象的作用：让我们在使用时可以预先知道一些事物所具有的特征，但是这些特征并不具体</li>
    </ul>
    <h4>对象的声明方式</h4>
    <ul>
        <li>var 对象名=new Object();创建一个空对象。</li>
        <li>给对象添加一些特征和行为：特征，称为对象的属性；行为，称为对象的方法。</li>
        <li>所有的方法都是函数类型，方法实际上也是属性，只不过保存的值为函数，所以起了一个特殊的名字。</li>
        <li>属性操作的两种方式：1.对象名.属性（已经确定使用的属性名）2.对象名["属性名"]（如果不确定属性名，可以通过变量获取）</li>
        <li></li>
    </ul>
    <h4>this的使用</h4>
    <ul>
        <li>this只有在方法中使用才有意义</li>
        <li>this在方法中指向函数的调用者</li>
        <li>好处，书写简便，可以将多个重复的方法合并为同一个对象。</li>
        <li>
            <strong>1 外面的this为new更改过指向后的对象
                2 内部的this指向当前函数的调用者(这个函数属于谁)</strong><br>
            function create(ageIpt) {

            //我们需要添加属性和方法，问题是属性和方法给谁设置？
            //在这里可以使用this进行属性和方法的设置
            this.name = "张三";
            this.age = ageIpt;

            //添加一个方法
            this.sayHi = function () {
            //方法内外的this的用法不同

            console.log("你好我是" + this.age);
            };
            }
        </li>
    </ul>
    <h4>构造函数创建对象</h4>
    <ul>
        <li>这种创建多个对象的形式我们称为构造函数方式创建</li>
        <li>使用函数创建对象时，由于多个对象的方法是相同的，会重复占用空间，可以使用命名函数的方式</li>
        <li>new关键字做的事情：
            1.创建一个对象。2.将当前函数内的this指向更改为使用new创建的对象。3.返回这个对象。
        </li>
        <li>使用new调用这个函数我们称为构造函数</li>
        <li>1.构造函数的命名，首字母大写（推荐，强烈推荐）</li>
        <li>2.调用构造函数时要使用new</li>
        <li>3.构造函数的作用：创建对象</li>
        <li>4.在构造函数中只需要做一件事，给this添加属性和方法</li>
        <li>在构造函数中不要写reture：1.reture基本类型值：会被忽略掉。2.reture
            复杂类型值，这是这个复杂数据类型会被返回，原有的对象会被替换。
        </li>
    </ul>
    <P>
        构造函数优化：1.使用一个对象，保存所有的函数。节约了名字和内存空间，但是还占有一个名字2.prototype属性在构造函数完成后，构造函数添加匿名函数。

    </P>
    <h4>prototype属性</h4>
    <ul>
        <li>prototype这个属性就是一个对象，作用为，放置公用方法</li>
        <li> Create.prototype.sayTianQi = function () {
            console.log("今天天气不错");
            };
        </li>
        <li>每个对象都具有一个属性 __proto__;这个属性与创建这个对象的构造函数的prototype是相同的值</li>
        <li>当我们使用一个对象的属性(方法)时,首先会查找这个对象本身，如果有，使用 ;如果没有，找这个对象的__proto__属性，就相当于查找Create.prototype</li>
        <li>这个对象叫做原型对象</li>
    </ul>
    <h4>补充说明</h4>
    <ul>
        <li>window浏览器环境下js的顶级对象，在页面其他位置使用this为window</li>

    </ul>
</div>


<div>
    <h2>第八天对象和DOM</h2>
    <h4>对象简介</h4>
    <ul>
        <li>在js中对象是用来描述一个具体事物的语法</li>
        <li>构造函数和抽象对应，对象和具体对应。</li>
        <li>1 构造函数创建 var obj = new Object(); var obj = new Create();</li>
        <li>2 字面量形式：(键值对集合的形式) 键 - 属性名 值 - 属性值</li>
    </ul>
    <h4>对象和数组的区别</h4>
    <ul>
        <li>对象是一个复杂数据类型：对象中可以保存多个数据；数组同样是复杂数据类型</li>
        <li>区别在于：数组是一种按照索引有序的数据存储方式，对象按照属性名保存是一种无序的数据存储方式</li>
        <li>由于对象是无序的数据存储方式，在遍历过程中就不能使用普通的for循环。</li>
        <li>使用for in循环遍历对象</li>
        <li>对象的属性不存在时，如果进行访问值为undefined(对象.属性)</li>
    </ul>
    <h4>json简介</h4>
    <p>通常情况下，通过前后端进行交互使用的数据称为json;
        JSON的数据形式和对象的字面量很像，区别在于属性名加了双引号（必须是双引号）
    </p>
    <h4>面向对象简介</h4>
    <ul>
        <li>面向对象：面向对象是一种思想，关注于对象</li>
        <li>面向过程：专注于过程</li>
        <li>面向对象的写法：会具体的实现一个功能的每个部分</li>
        <li>面向对象思想实际上就是：拿来主义（拿过来用即可）</li>
    </ul>
    <h4>DOM</h4>
    <ul>
        <li>DOM- document object model 文档对象模型</li>
        <li>DOM提供一些方式，用来操作页面的元素。（在DOM中标签称为元素-页面元素）</li>
        <li>document是一个对象，并且在DOM中的顶级对象</li>
        <li>document.getElementById("id")传入一个字符串类型的标签id名，该方法获取返回该标签，取不到值返回null</li>
        <li>window.onload=函数;人口函数：在人口函数中书写的代码会在页面完全加载后（页面结构，图片，文件）执行</li>
        <li>每个标签都具有style属性，用于获取样式。通过：标签.style
            .具体的样式名；通过js设置的样式，最终在标签的行内生效（样式的权重很高）
        </li>
        <li>操作文本的属性：标签.innerHTML属性；可以获取修改标签内部的文本+标签</li>
        <li>防止覆盖：使用innerHTML+=的方式可以避免原内容被覆盖的问题</li>
        <li>新问题：即便使用+=可以解决覆盖，如果原有的内部标签具有了事件，这时由于新旧标签不同，这个事件会失效</li>
        <li>根据标签名获取元素：document.getElementsByTagName("标签类型")；
            不支持数组方法，但是有长度有索引，是一个伪数组形式。
        </li>
        <li>标签行内自带的（js自己支持的）属性，可以通过标签.属性名的方式进行直接操作</li>
        <li>注意：直接通过id.innerHHTML，浏览器会自动帮我们获取并使用，但这种写法不规范，容易出其他错误</li>
        <li>css的属性在js中，例如 background-color，在js中操作时需要修改为驼峰命名法backgroundColor (去掉横线，后半部分首字母大写)</li>
    </ul>
    <h4>事件</h4>
    <ul>
        <li>捕捉用户的操作称为事件；</li>
        <li>事件源：触发事件的元素（被动）</li>
        <li>事件类型：触发了什么事件</li>
        <li>事件处理程序：事件触发后，相应要执行的效果（函数结构）</li>
        <li>事件的语法格式：事件源.事件类型=function(){};</li>
        <li>onclick用户点击事件</li>
    </ul>
</div>
<div>
    <h2>第九天</h2>
    <h4>src和href的区别</h4>
    <ul>
        <li>href作为链接到外部资源直接使用</li>
        <li>src会将获取到的值，替换标签内的内容，进行显示（使用）</li>
        <li>给a标签注册点击事件，如果不想进行跳转，可以在自定义事件结束位置书写 return false;</li>
    </ul>
    <h4>在循环中添加事件时事件中使用循环变量的两个方法</h4>
    <ul>
        <li>采用自调用函数，在自调用函数中声明一个变量，存储循环变量。（会创建多个自调用函数，不推荐）</li>
        <li>使用标签的自定义属性，把循环标量存储到标签中。标签对象.自定义属性名=循环变量；</li>
    </ul>
    <h4>标签行内的类名className</h4>
    <ul>
        <li>类名的好处：使用类名可以让样式操作更加简便，利于css和js代码的分离</li>
        <li>取消类名和加入新类名来操作样式</li>
        <li>设置类名时，由于js设置的样式显示在行内，权重较高，类名无法对其进行覆盖，需要添加!important</li>
    </ul>
    <h4>事件</h4>
    <Ul>
        <li>移入事件 onmouseover;移出事件 onmouseout</li>
        <li>字符串.replace("匹配项","替换值");字符串的不可变性:所有的字符串方法，均会在操作后，返回修改后的结果，而无法修改原字符串</li>
        <li>输入框焦点事件：onfocus（获取焦点）和onblur（失去焦点）</li>
        <li>标签属性：disabled，checked，selected值在js中为Boolean；可以使用非bool值，会隐式转换后，根据转换结果进行操作</li>
        <li>纯文本时innerText性能高于innerHTML</li>
    </Ul>
    <h5>表单的基本操作</h5>
    <ul>
        <li>文本操作：通常使用value属性</li>
        <li>textarea 可以使用value和innerHTML</li>
        <li>select中的option：只能使用innerHTML，具有value属性但是不是文本操作的作用</li>
    </ul>
    <h4>Tab切换的两种方法</h4>
    <p>针对法：定义一个变量赋默认值0，在循环中每个子元素的注册事件中，先清掉当前变量对应的子元素选择样式，第二步给当前点击
        的元素加选择样式，第三个给变量赋值为当前子元素的索引（通过自定义属性给子标签加索引）</p>
    <p>排他法：先通过循环清除所有子元素的样式，然后在给当前子元素加元素。优点：实现简单。缺点：性能差</p>
</div>
<div>
    <h2>第十天dom获取文档标签及兼容性</h2>
    <p>能力检测：检测浏览器行不行（检测支持哪一个功能）;使用特定的某个属性和方法，在执行时查看执行的结果，如果可以，就使用该功能，如果不行，使用其他对应的功能；</p>
    <h4>innerText和textContext（都是操作纯文本）</h4>
    <ul>
        <li>innerText属性是ie提出的，其他浏览器兼容性不好</li>
        <li>textContext其他浏览器支持，但ie9下不支持</li>
        <li>如果浏览器不识别这个属性，返回undefined</li>
    </ul>
    <h4>获取计算后的样式</h4>
    <ul>
        <li>getComputedStyle(要进行样式获取的标签,null) 获取计算后的样式:可以获取各种位置设置的样式值</li>
        <li>第二个位置表示某个标签的伪元素，通常传入null或者0或者false；使用getComputedStyle获取的结果是所有样式的集合(对象形式)</li>
        <li>ie低版本(ie9以下)不支持这个标准方法getComputedStyle()</li>
        <li>ie使用 标签.currentStyle 获取结果与getComputedStyle()的结果相同</li>
    </ul>
    <h4>getElementsByClassName</h4>
    <ul>
        <li>ie9以下不支持</li>
        <li>能力检查后自己实现</li>
        <ul>
            <li>document.body.getElementsByTagName("*")可以通过通配符的方式获取所有的标签进行判断</li>
            <li>按照空格把获取到每个标签的类名进行split，和传入的类名进行对吧，一样的加入一个新数组</li>
            <li>优化：tagElement（标签对象）||document.body按照断路的方式，如果传入了标签对象，则获取这个标签下所有带有该类名的标签</li>
        </ul>
    </ul>
    <p>标签对象.style.cssText= "width:100px;height:100px;";使用一个样式属性 cssText 可以一次给标签添加多个样式；cssText用于添加css形式的样式值</p>
    <h4>节点树</h4>
    <ul>
        <li>html生成的这个树称为节点树（树模型）;树模型上有多个不同的部分，每个部分我们称为节点</li>
        <li>节点的分类：元素节点 - 标签;文本节点 - 文本;属性节点 - 属性;注释节点 - 注释（不会进行操作，不常用）</li>
        <li>document - 节点根</li>
        <li>节点树带给我们的好处；根据节点之间的上下级(父子关系)、同级(兄弟)，提供了一套访问的方式</li>
    </ul>
    <h4>节点访问方式</h4>
    <ul>
        <li>通过节点访问关系获取的结果，如果是数组形式的数据，全都是伪数组。</li>
        <li>会获取文本节点的方法，其中文本包括标签正常的空格换行</li>
        <li>父子节点访问方法
            <ul>
                <li>想要通过一个节点，访问他的上级节点(父节点、父元素)语法：节点.parentNode;注意：任意节点的父节点，永远是元素节点(标签)，不可能是其他类型的节点。</li>
            </ul>
        </li>


        <li>子节点访问
            <ul>
                <li>获取所有子节点:节点.childNodes;获取的值，包含标签内部所有的子节点（元素节点，文本节点（换行和空格））</li>
                <li>获取所有的子元素节点:节点.children;获取的值为标签内部的所有子标签，不含文本节点;children不是一个标准属性，但是由于特性非常好用，导致所有的浏览器均支持此属性</li>
            </ul>
        </li>
        <li>
            获取子元素第一个或最后一个元素子节点
            <ul>
                <li>节点.firstElementChild和节点.lastElementChild，不会获取到文本节点，但ie9下不支持</li>
                <li>节点.firstChild和节点.lastChild，会获取文本节点，但没有兼容性问题</li>
            </ul>
        </li>
        <li>
            获取兄弟节点前一个或者后一个
            <ul>
                <li>节点.previousSibling和.nextSibling 会获取到空格和换行</li>
                <li>节点.previousElementSibling和节点.nextElementSibling 不会获取文本节点，但ie低版本不支持</li>
                <li>如果通过同级访问关系获取不到元素,结果为null</li>
                <li>封装节点.previousSibling和.nextSibling，遇到空格和换行（判断节点类型）直接向外跳一级查元素和为null直接返回，可以得到只获取前后元素的方法（第十二天视频进行了封装）</li>
            </ul>
        </li>
    </ul>
    <h4>节点位置移动方式(移动节点的方式:移动节点，类似与剪切操作;)</h4>
    <ul>
        <li>父节点.appendChild(要进行添加的节点) 追加子节点;添加位置为父节点的所有子节点最后。</li>
        <li>父节点.insertBefore(要插入的元素,参考的子节点) 插入子节点;添加位置为指定的子节点前面。</li>
        <li>insertBefore的第二个参数不传也是可以使用的（不是完全不传，而是传一个没有用的值）;可以传的值为null和undefined</li>
        <li>这个方法的规范中指出两个参数均为必须传入的参数，所以这种方式使用时需要谨慎对待(因为官方没有明确说明，以后可能会改)</li>
        <li>如果值为null和undefined时，传入的位置为最后。</li>
    </ul>
    <h4>节点访问伪数组长度死循环问题</h4>
    <p>在节点访问关系中，获取的数组结构数据均为伪数组;这些伪数组结构均为动态的;我们在操作时，每次向box中添加一个新的标签时，不要使用box.children的length作为判断添加
        问题是，由于伪数组结构是动态的数组形式，导致死循环的问题;如果想要采用伪数组的元素个数作为循环的执行次数使用，需要先进行保存到一个变量中，然后这个变量做循环参数。
    </p>
</div>
<div>
    <h2>第十一天dom,动态创建删除元素，innerHTML性能，onkeyup事件</h2>
    <h4>动态创建元素几种方式</h4>
    <ul>
        <li>动态创建元素的作用：
            <ul>
                <li>1.减少流量消耗</li>
                <li>2.提高网页的加载速度</li>
                <li>3.增强网站的可维护性</li>
             </ul>
        </li>
        <li>document.write();
            <ul>
                <li>插入位置，为body的最底部</li>
                <li>问题1 ：不能在某个指定的标签内部进行结构创建</li>
                <li>问题2： 如果在页面加载后(事件中)使用document.write()会导致原有的页面被覆盖</li>
                <li>页面在渲染时:1 默认加载(第一次加载页面)：称为一次输出流 （将效果输出到页面上）2 document.write() 如果在页面加载后使用，会开启一个新的输出流（导致原有输出流的内容被清除）</li>
                <li>解决方式：不要在页面加载后使用document.write();</li>
            </ul>
        </li>
        <li>标签.innerHTML
            <ul>
                <li>好处：灵活，可以给任意的标签内部进行结构创建;坏处：性能极差</li>
                <li>只需要减少innerHTML的使用次数即可</li>
                <li>拼接字符串老式的使用方式是使用数组然后.join("")：因为低版本浏览器对字符串操作的优化不好</li>
                <li>+=innerHTML操作会把元素注册的事件干掉</li>

            </ul>
        </li>
        <li>document.createElement("标签名")  可以进行标签的创建
            <ul>
                <li>使用document.createElement() 创建的元素，不存在于页面中</li>
                <li>如果想要显示，需要使用移动节点的方式，将创建的元素添加到页面中的某个位置即可</li>

            </ul>
        </li>
        <li>根据下面的各种例子总结的规律：
            <ul>
                <li> 1 当结构十分复杂时，使用innerHTML非常方便，直接拼接即可.</li>
                <li>2 当我们需要向一个标签添加新元素时，如果这个标签内部已经具有了其他的内容，这时使用document.createElement()可以不影响原始的标签</li>
            </ul>
           </li>

    </ul>
    <h4>事件，元素删除及字符串判断位置</h4>
    <ul>
        <li>父节点.removeChild(要删除的子节点);</li>
        <li>on key 键 up起来;onkeyup 按键按下去，抬起来的一瞬间，触发事件</li>
        <li>字符串方法indexOf;  返回从左往右第一次找到的指定字符串的索引值</li>
    </ul>
    <h3>查看此代码执行的时间  console.time("key") 与console.timeEnd("key")前后key一致</h3>
    <p>最好不要使用父级作用域中的变量;通过节点之间的访问关系，可以防止父作用域执行后不进行释放的问题。</p>
    <p>/和"++"一样可以对字符串的换行起作用</p>
</div>
<div>
    <h2>第十二天节点，bom</h2>
    <h4>重排和重绘</h4>
    <ul>
        <li>
            <ul>
                <li>1 当页面加载生成渲染树(节点树和样式树合并的产物)后;按照渲染树上的每一个部分，将页面显示出来</li>
                <li>2 排列：根据某个标签的宽高，定位值，浮动，计算出标签要显示的位置</li>
                <li>3 绘制：显示内部的内容，图片，颜色，文本</li>
            </ul>
        </li>
        <li>当用户对页面进行操作时(js操作)，可能会引发重新排列(重排、回流)和重新绘制(重绘)</li>
        <ul>
            <li>重排和重绘均会引发性能问题：重排的性能消耗要高于重绘</li>
            <li>重排的出现位置，决定了他消耗的性能(尽量减少一个元素在进行操作时所可以影响的元素个数)</li>
            <li>重排是必然引发重绘，但是重绘是可以单独触发的。</li>
            <li>尽量要减少操作所引发的重排次数</li>
        </ul>
        <li>document.createDocumentFragment();作用：当我们将df放入到页面中时，自己不会像标签一样一同放入，而是放入内部的元素</li>
    </ul>
    <h4>节点克隆与替换</h4>
    <ul>
        <li>节点.cloneNode();</li>
        <ul>
            <li>1 可以传入参数，如果不传，默认为false，表示浅复制（只复制标签，不复制内部的内容）;如果参数值为true，表示深复制(复制标签以及内部的内容)</li>
            <li>2 克隆节点后，标签相同，但是不会具有内部的事件(等等的属性都没有);所有在标签结构中看不到的属性均无法克隆</li>
            <li>3 要克隆的标签不要添加id，添加id以后，id名会重复</li>
            <li></li>
        </ul>
        <li>标签.replaceChild(要替换成哪个标签,要替换的子元素);返回值为被替换掉的标签</li>
    </ul>
    <h4>节点属性</h4>
    <ul>
        <li>节点是对页面中所有内容的统称(节点树中的每个部分)</li>
        <li>
            <ul>
                <li>节点.nodeType  用于查看每个节点的节点类型：元素节点  1；文本节点  3；属性节点  2；document  9；documentFragment 11</li>
                <li>nodeName  节点名；元素节点的nodeName属性为标签名,在html中是大写形式,在xhtml中是小写形式</li>
                <li>nodeValue 节点值；元素节点没有节点值，访问时值为null</li>
           </ul>
        </li>
    </ul>
    <h4>标签的属性</h4>
    <ul>
        <li>标签自带的行内属性可以通过 标签.属性名直接操作;标签行内的自定义属性操作：使用.属性名访问不到
            <ul>
                <li>1 属性获取:标签.getAttribute("属性名")</li>
                <li>2 属性设置：标签.setAttribute("属性名")</li>
                <li>3 属性移除：标签.removeAttribute("属性名")</li>
                <li></li>
                <li></li>
            </ul>
        </li>

        <li>属性节点的获取方式：var node= 标签.getAttributeNode("属性名")
            <ul>
                <li>node.nodeType//2</li>
                <li>node.nodeName//id 属性名</li>
                <li>node.nodeValue//属性值，取值与getAttribute取值相同</li>
             </ul>
        </li>

    </ul>
    <h4>bom</h4>
    <ul>
        <li>BOM - browser object model 浏览器对象模型;作用：将浏览器内部的功能作为对象形式进行使用;BOM中的顶级对象 - window</li>
        <li>所有的全局变量均为window的属性;window的属性和方法均不需要(可以忽略)加window;使用window的方式可以直接访问全局变量的值</li>
        <li>location也是window的属性。同样也是一个对象形式，内部具有许多的属性和方法
            <ul>
                <li>location具有一个属性href，会跳转到指定的页面</li>
                <li>location.assign(地址); 同样也是跳转功能;和href功能基本一样</li>
                <li>location.replace(地址); 跳转，但是无法进行返回(无法后退)</li>
                <li>location.reload(); 刷新</li>
                <li>
                    <ul>
                        <li>window.location.hash;//锚点</li>
                        <li>window.location.host;//主机</li>
                        <li>window.location.hostname;//域名</li>
                        <li>window.location.pathname;//当前页面的路径</li>
                        <li>window.location.port;//端口 80</li>
                        <li>window.location.protocol;//协议</li>
                        <li>window.location.search</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>window.navigator.platform//平台，可以检测当前运行的系统是什么;window.navigator.userAgent//用户代理字符串  简称UA</li>
        <li>history.go(1); history.forward();//前进history.go(-1);history.back();//后退</li>
        <li>window.open()//open()方法: 参数1 打开地址 参数2 打开位置 _blank _self 参数3 可以设置新窗口的样式
        <ul>
            <li>close方法,用于关闭窗口</li>
            <li>moveTo(w,h),moveBy(w,h)修改窗口大小</li>
            <li>resizeTo(x,y)，resizeBy(x,y)移动窗口位置</li>
        </ul>
        </li>

    </ul>
</div>
<div>
    <h2>第十三天</h2>
    <p> 内置对象:类似与电脑的内置软件，具有一些自带的功能；
    由于每个方法使用的数据不同，又形成了不同的集合（对象），称为内置对象
    </p>
    <h4>内置对象数组的方法</h4>
    <ul>
        <li>数组.push(参数1,参数2,..........);
            <ul>
                <li>表示将传入的参数依次添加到数组的最后</li>
                <li>可以修改原数组，返回值为修改后数组的新长度</li>

            </ul>
        </li>
        <li>数组.pop():从数组的最后删除一个元素，并且返回。修改原数组</li>
        <li>数组.unshift(参数1,参数2,..........)从数组最前面进行添加;按照传参的顺序，将数据添加到数组最前面;返回数组的新长度</li>
        <li>数组.shift();从数组最前面删除一个元素</li>
        <li>数组.concat()
            <ul>
                <li>用于进行数组的连接,如果参数为数组形式，不会将整体放入，而是将传入的数组中每个元素进行放入</li>
                <li>不会修改原数组，而是返回一个结果数组</li>
                <li>利用返回新数组的特性，可以进行数组的复制</li>
             </ul>
        </li>
        <li>slice()  拷贝
            <ul>
                <li>数组.slice(start,end);</li>
                <li>作用为，拷贝数组中指定的数据，从索引值start开始拷贝到索引值end位置，不含end位置的值</li>
                <li>不会修改原数组，返回值为拷贝的内容</li>
            </ul>
        </li>
        <li>splice()  截取
            <ul>
                <li>数组.splice(start,len)  start表示截取的起始位置索引值，len表示截取的个数</li>
                <li>修改原数组，返回值为截取到的元素，数组形式返回</li>
                <li>添加数据，如果传入的参数多于2个,将后面的这个参数添加 到截取的位置上(个数不需要对应)</li>
                <li>splice的作用：可以删除数组中的指定元素;</li>
            </ul>
        </li>
        <li>数组.reverse();翻转数组:可以修改原数组，返回值与原数组是同一个数组，所以没有必要接收</li>
        <li>数组.sort();
            <ul>
                <li>可以对字符串数组进行排序，默认为按照a-z的顺序排序，如果数组的元素具有多个字符，按照首字母排序</li>
                <li>可以对数值数组进行排序,用冒泡排序模拟写出sort传函数的排序方式</li>

            </ul>
        </li>
        <li>indexOf():返回值为，从左往右找到的第一个满足条件的元素的索引值(只能找到一个);如果没有找到指定的元素值，返回-1</li>
        <li>lastIndexOf:使用方式与indexOf相同，只不过查找的起始位置为从后往前;数组的indexOf和lastIndexOf方法在ie9以下不支持</li>

    </ul>
    <h4>Date对象</h4>
    <ul>
        <li>Date对象的作用：表示时间;</li>
        <li>Date对象的创建方式：var date = new Date();//构造函数创建方式，给当前的时间创建了一个对象形式</li>
        <li>传参可以创建某一个特定时间的对象：var date = new Date("2015-1-1");</li>
        <li>如果参数是数值类型，月份从0开始:var date = new Date(2015, 11, 1);</li>
        <li>转换方式： 会将当前的日期转换为毫秒形式
            <ul>
                <li>var date = new Date();console.log(date.getTime());console.log(+new Date());</li>
                <li>console.log(Date.parse("2015-1-1"));</li>
                <li>var date = new Date();console.log(date.valueOf());</li>
                <li>Date.now();</li>
            </ul>
        </li>
        <li>
            Date的内置方法
            <ul>
                <li>console.log(date.getFullYear());//获取年份</li>
                <li>console.log(date.getMonth() + 1);//获取月份，月份从0开始</li>
                <li>console.log(date.getDate());//获取日</li>
                <li>console.log(date.getDay());//星期也是从0开始，0表示周日</li>
                <li>console.log(date.getHours());//获取小时</li>
                <li>console.log(date.getHours());//获取小时</li>
                <li>console.log(date.getMinutes());//获取分钟</li>
                <li>console.log(date.getSeconds());//获取秒</li>
                <li>console.log(date.getMilliseconds());//获取毫秒  0-999</li>

            </ul>
        </li>
    </ul>
    <h4>字符串对象</h4>
    <ul>
        <li>字符串就是一个基本类型数据;由于字符串是一个非常常用的数据类型，许多基本的操作，如果每次都要书写代码实现非常的麻烦;</li>
        <li>js会在每次使用字符串的属性和方法时，给我们创建一个与该字符串数据值相同的字符串对象;当属性使用完毕后，这个对象会被立刻清除</li>
        <li>这种对象我们称为 基本包装类型对象 。</li>
        <li>length表示字符串的字符个数;按照索引访问字符,由于字符串的不可变性，操作时只能进行访问，而无法修改。字符串.charAt(索引值) 使用结果与[]的方式相同</li>
        <li>字符串.concat();作用为连接字符串;这个方法通常不用，一般使用+操作，更简便</li>
        <li>字符串.slice(start,end);slice方法可以传入负数的参数，表示从后面数第几个</li>
        <li>字符串.substr(start,len)  len表示个数</li>
        <li>字符串.substringe(start,end);不支持负数的参数，如果传入了负数，会认为是0;如果参数2的值小于了参数1，自动交换位置</li>
        <li>字符串大小写转换：小转大/字符串.toUpperCase()；大转小/字符串.toLowerCase()</li>
        <li>字符串.indexOf("要检索的字符串",起始位置索引值);字符串的index系列方法没有兼容性问题</li>
        <li>语法:str.replace("要替换的字符串","替换为什么字符串")作用为从左往右，替换掉找到的第一个指定字符串(可以循环替换全部)</li>
        <li>字符串.split("用于分割的字符串")  返回分割后的数据，数组形式</li>
        <li>字符串.trim()去除字符串两端的空格</li>

    </ul>
    <h4>两种定时器</h4>
    <ul>
        <li>timeout定时器:延时执行;设置：setTimeout(执行的代码,延时时间)  时间为毫秒单位。返回值为当前定时器的唯一标识;clearTimeout(定时器标识id)</li>
        <li>interval:每间隔一段时间重复执行代码;设置：setInterval(执行的代码,执行间隔时间)  时间为毫秒单位。;返回值为当前定时器的唯一标识;清除方式: clearInterval(定时器id);</li>
        <li>问题是：由于异步任务不是时间到达立刻执行，而是时间到达后将任务代码添加到主线程中进行排队；如果当前的同步任务列表中的代码执行时间很长，可能会导致定时器执行时间不准确</li>
        <li>当定时器内部的代码停止执行后，记得清除定时器</li>
    </ul>
    <h3>单线程和多线程丶同步和异步</h3>
    <ul>
        <li>单线程和多线程：
            <ul>
                <li>单线程就是做事情的人只有一个。</li>
                <li>js是单线程的语言：如果设置为多线程，会导致dom等关键操作出现问题</li>
                <li>h5以后js引入了多线程的概念，但是只能有一个主线程，其他线程无法进行DOM等核心操作，可以进行其他的细节处理，提高代码执行速度</li>
            </ul>
        </li>
        <li>同步和异步：
            <ul>
                <li>单线程同步：一个人只能按照顺序一次做一件事情。</li>
                <li>同步的问题：由于有些任务比較耗时，或者执行的时间不确定，这时无法使用同步任务（会导致后面的功能阻塞）</li>
                <li>异步任务：当某些任务比較耗时时，或者执行的时间不确定时，这些任务不会添加到主线程中进行执行，而是放到一个任务队列中</li>
                <li>异步任务的执行总是晚于同步任务；当异步任务可以执行时无法插入到已经存在的任务之间，只能排队到当前所有任务的最后等待执行</li>
                <li>js中的常见异步任务：定时器，事件</li>
            </ul>
        </li>

    </ul>
</div>
<div>
    <h2>第十四天</h2>
    <h4>旋转属性：/*旋转角度为顺时针*/ transform: rotate(30deg);</h4>
    <h4>简单运动</h4>
    <ul>
        <li>/使用标签.offsetLeft 用于获取标签距离定位父盒子的左侧距离 //获取结果是数值类型,并且只读(无法进行修改)</li>
        <li>offsetLeft的取值会取到真正应用的一个值，会进行四舍五入:每个像素点同时只能显示一个颜色，从根本上来说设置一个元素的样式为宽度20.3，根本没有意义</li>
        <li>计算方式为：当前元素的左边框左侧，到定位父盒子的左边框右侧(边框到边框之间的距离)</li>

        <li>标签.offsetWidth 可以获取元素的真实宽度(border + padding + width)(除了margin以外的所有值的宽度)获取结果是数值类型,只读（不能设置）</li>
        <li>1 在定时器内部先获取到元素当前所在位置的left值（可以避免默认left值变动和后期操作更改left的问题）</li>
        <li>2 简单运动公式  当前位置 = 当前位置 + 步长</li>
        <li>3 将新的位置设置给box的left，进行运动</li>
        <li>4.到达位置清除定时器</li>
        <li>多个盒子抖动:最终的修改是，将timer不作为全局变量或者局部变量，而是作为某个标签的一个自定义属性。</li>
    </ul>
    <h4>网络加载的速度对页面图片的尺寸获取有影响(这种情况不可控)。</h4>
    <ul>
        <li>入口函数：当页面完全加载后执行代码</li>
        <li>当我们需要使用某个图片的尺寸时</li>
        <li>方式1：可以获取可视区域的宽度</li>
        <li>方式2：有时我们的页面结构是动态创建的,会根据接受的数据进行结构创建，数据中会保存图片等内容的尺寸</li>
    </ul>
    <h4>列子</h4>
    <ul>
        <li>简单轮播图</li>
        <li>左右焦点图</li>
        <li>无缝滚动原理</li>
        <li>机械表</li>
     </ul>
</div>
<div><h2>第十五天加速滚动封装，轮播图和手风琴</h2>
    <p> //事件传递的默认方式，称为事件冒泡
        //当前元素触发事件后，自己的事件会执行，执行后会向父元素进行传递，如果父元素具有相同类型的事件，也会被触发</p>

</div>
<div>
    <h2>第十六天</h2>
    <h4>offset系列属性</h4>
    <ul>
        <li>offsetLeft:用于获取当前元素到定位父盒子的左侧距离  (边框到边框)</li>
        <li>offsetTop:用于获取当前元素到定位父盒子的顶部距离  (边框到边框)</li>
        <li>offsetWidth:用于获取元素的真实宽度（不含margin）</li>
        <li>offsetHeight:用于获取元素的真实高度（不含margin）</li>
        <li>offsetParent 相当于一个选择器 /获取的值为当前元素参考的定位父盒子</li>
        <li>parentNode 获取的父元素(紧贴着的父级标签) </li>
    </ul>
    <h4>scroll系列属性</h4>
    <ul>
        <li>scrollTop 元素的卷曲高度;计算方式，当元素内部的内容超出了元素的顶边框的底部时，开始进行计算</li>
        <li>onscroll 滚动事件（元素的内部滚动条滚动时触发事件）</li>
        <li>scrollLeft 元素卷曲的宽度（左侧的距离）;计算方式：当元素内部的内容超出了元素的左边框的右侧时，开始进行计算</li>
        <li>scrollHeight 元素内部内容的真实高度;计算方式为，从顶边框的底部，计算到内部内容的底部</li>
        <li>scrollHeight具有最小值;计算方式：顶边框和底边框之间的距离</li>
        <li>scrollWidth  元素内部内容的真实宽度</li>
        <li>获取页面的卷曲高度兼容性问题
            <ul>
                <li>window.pageYoffset(在ie9以下不支持)具有一个别名 window.scrollY(但是scrollY在ie中全都不支持，所以通常使用pageYoffset)</li>
                <li>document.body.scrollTop(只有谷歌好使)</li>
                <li>document.documentElement 指的是html标签(只有谷歌不好使)</li>
                <li> scrollTop: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0</li>
                <li> scrollLeft: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0</li>
             </ul>

        </li>
    </ul>
    <h4>client系类属性</h4>
    <ul>
        <li>标签.clientHeight 元素内部的真实高度;计算方式：边框到边框之间的距离;这个值与scrollHeight的最小值相同</li>
        <li>标签.clientWidth 元素内部的真实宽度;</li>
        <li>clientTop,clientLeft比較鸡肋： 相当于顶边框和左边框的宽度值;如果元素具有滚动条，并且左侧显示，会影响到clientLeft的取值（会增加17px的宽度）</li>
        <li>onresize 当页面尺寸改变时，触发事件</li>
        <li>获取可视区域宽度的方式
            <ul>
                <li>width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth || 0</li>
                <li>height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0</li>
            </ul>
        </li>

    </ul>
    <p>可以把内容滚动到指定的区域：window.scrollTo(100, 200);参数1 表示横向的坐标;参数2 表示纵向的坐标</p>
</div>
<div>
    <h2>第十七天 事件</h2>
    <h4>简单事件与复杂事件，事件冒泡与事件捕获</h4>
    <ul>
        <li>事件三要素 ： 事件源 事件类型 事件处理程序;简单事件添加方式：事件源.事件类型 = function(){事件处理程序}</li>
        <li>问题：简单事件添加会出现覆盖的情况;解决：可以通过检测onclick属性中的值，如果是函数，说明添加过，如果什么也没有说明没加过</li>
        <li>标签.addEventListenter(eventtype(事件类型),fun（事件处理程序）,bl（事件的传递方式）)  添加事件监听;此方法在ie9以下不支持</li>
        <li>事件的移除方式：
            <ul>
                <li>1 简单事件的移除：btn.onclick = null;</li>
                 <li>语法 标签.removeEventListener(事件类型,事件处理程序)</li>
                <li>移除时，所有的参数必须与设置时完全相同;注意：第二个参数必须与设置时是同一个函数才行</li>
            </ul>
        </li>
        <li>ie11以下支持方法
            <ul>
                <li>注意点：只有ie11以下支持此方法（此方法注定要被淘汰，只不过是时间问题）</li>
                <li>在ie9以下注意执行的顺序相反（对实际的操作不影响）</li>
                <li>标签.attachEvent()移除方式  标签.detachEvent("onclick",对应的事件处理程序)</li>
            </ul>
        </li>
        <li>事件的默认传递方式：事件冒泡;执行顺序，当前元素触发事件后，会向父元素进行传递，如果父元素具有相同的事件，进行触发</li>
        <li>事件捕获需要使用特殊的设置方式（了解）
            <ul>
                <li>addEventListener的第三个参数;值为bool值，默认值为false，false表示事件冒泡;设置值为true表示以事件捕获的方式触发事件</li>
                <li>事件捕获的执行顺序与事件冒泡的执行顺序相反</li>
                <li>attachEvent方法不支持第三个参数。意味着在ie的低版本中不支持事件捕获</li>

            </ul>
        </li>
        <li>一个事件的执行都有三个必要过程：1 事件捕获（从外到内）;2 当前操作元素的事件触发;3 事件冒泡（从内到外）</li>
        <li>注意：我们设置的事件冒泡和事件捕获只能决定这个事件在哪一个阶段进行触发;eventPhase 属性可以知道某一个事件触发时处于事件执行的哪一个阶段中</li>
        <li>事件传播阻止：同时取消两种传播方式  事件对象.stopPropagation();ie低版本中不支持此方法;可以取消事件冒泡：window.event.cancelBubble = true;</li>
        <li>取消标签的默认事件的两种方法：return false 可以阻止默认事件效果；事件对象.preventDefault();</li>
        <li>onmousemove：当鼠标在页面中进行移动时，实时获取鼠标的位置</li>
        <li>onmousedown 当鼠标点下去的时候触发事件</li>
        <li>onmouseup 当鼠标按键抬起的时候触发事件</li>
     </ul>

    <h4>事件对象</h4>
    <ul>

        <li>在其他浏览器中获取：事件处理程序中接受形参event/e;ie浏览器：window.event;兼容 e || window.event;</li>
        <li>type属性：可以获取当前这个事件的类型名,没有on</li>
        <li>针对页面可视区域的横纵坐标:事件对象.clientX 横坐标;事件对象.clientY 纵坐标</li>
        <li>pageX pageY 鼠标针对页面的坐标,ie低版本中无法使用此属性,使用clientX/clientY + 页面卷曲的宽度/高度解决这个问题</li>

    </ul>
    <h4> 事件委托(事件代理)：解决动态创建元素事件的问题。</h4>
    <ul>
        <li>借助事件冒泡的特性，将事件添加给父元素后可以保证无论是否是动态创建的p都可以具有事件</li>
        <li>可以在事件处理程序中接受一个参数event----形参，这个参数不是我们自己传递的而是js的事件机制帮我们传递的</li>
        <li>event.target 代表了当前事件真正触发的那个元素ie低版本中使用 event.srcElement</li>
        <li>对target进行兼容: var tar = event.target || event.srcElement;</li>
    </ul>

</div>
<div>
    <h2>第十八天 正则和递归</h2>
    <h4>正则表达式的作用：操作字符串 (匹配，替换，提取)</h4>
    <ul>
        <li>正则表达式两种声明方式：构造函数声明方式 var reg = new RegExp("abc");字面量声明方式 var reg = /abc/;</li>

        <li>五大内部类
            <ul>
                <li>var reg = /abc/;简单类：可以匹配含有abc的字符串</li>
                <li>var reg = /[abc]/;字符类标识：使用[],中括号整体表示一位字符;可以匹配到含有字符a或者b或者c的字符串</li>
                <li>var reg = /[^abcd]/;反向类是对字符类功能的扩展,在字符类的标识[后面书写一个^，可以表示反向,可以匹配到除了abcd以外的其他字符串</li>
                <li>var reg = /[a-n]/;对于匹配的字符数较多的情况，可以使用范围类</li>
                <li>var reg = /[a-h1-7D-O]/;组合类：对范围类书写的组合。匹配 a到h之间的小写字母和1-7之间的数字和D-O之间的大写字母。种匹配情况的书写顺序随意。</li>
            </ul>
        </li>
        <li>边界：^书写在正则的最开始部分,表示开头；将$书写在正则的最后位置，表示匹配结尾；如果同时在一个正则中书写了^和$，表示严格匹配：必须与内部的内容完全相同</li>
        <li>量词
            <ul>
                <li>当需要匹配的内容重复出现的次数较多时，可以使用量词</li>
                <li>{n} 表示可以出现的次数</li>
                <li>{n,} 可以出现的次数>=n</li>
                <li>{n,m} 可以出现的次数为n-m之间</li>
                <li>
                    预定义的三个量词使用
                    <ul>
                        <li>* 出现的次数可以为0次到多次</li>
                        <li>+ 出现的次数可以为1次到多次</li>
                        <li> ? 出现的次数可以为0或1次</li>
                    </ul>
                </li>
            </ul>
        </li>
       <li>
         |或则，匹配的字符为多个并且不确定：  var reg = /ab|bc|cd|it/;
       </li>
        <li>正则方法
            <ul>
                <li>正则对象.test()方法:正则方法;参数为字符串，表示使用正则表达式对字符串进行匹配，匹配成功返回true，失败返回false</li>
                <li>
                    字符串.replace();replace的第一个参数可以使字符串，也可以是正则表达式
                    <ul>
                        <li>g - 全局匹配,str.replace(/c/g, "z");基本的正则表达式匹配到一个结果后就会停止，如果希望匹配到所有满足条件的字符部分，可以使用匹配模式g</li>
                        <li>i - 忽略大小写,str.replace(/c/gi, "z")</li>
                        <li></li>
                    </ul>
                </li>
                <li>正则基本的提取方式(两种)：
                    <ul>
                        <li> 字符串.match(reg);参数为正则表达式，返回一个匹配到的数组</li>
                        <li>正则.exec();,参数为一个字符串，使用exec方法时，如果用一个正则对象进行多次匹配，结果为进行累计，如果第一轮匹配结束，会返回null，如果再次匹配，会从头开始</li>
                        <li>exec的分组提取功能：var reg = /(\w+)@(\w+\.\w+)(?:\.\w+)*/g;使用括号可以进行分组提取，如果某一个括号中的内容不需要进行提取，可以在这个括号的开始部分添加?:</li>
                    </ul>
                   </li>

            </ul>
        </li>
        <li>\s表示一个空格；\w表示除汉字外其他字符，\d表示数组</li>
    </ul>
    <h4>递归：函数内部自己调用自己</h4>
    <ul>
        <li>计算1-10之间所有数的和</li>
        <li>斐波那契数列（兔子）  1 1 2 3 5 8 13(可使用对象保存方法返回值的方式进行优化)</li>
     </ul>
</div>
<div>
    <h2>第十九天jQery</h2>
    <h4>js和jq区别</h4>
    <ul>
        <li>
            js:1 入口函数的个数只能有一个;2 简单基本的dom操作，十分繁琐;3 兼容性问题;4 容错性差;5 制作简单的运动十分麻烦
        </li>
        <li>jq实现入口函数的两种方式：$(document).ready(function(){});$(funtion())</li>
        <li>jq的入口函数执行要比js的入口函数早:
            <ul>
                <li>js的入口函数：页面完全加载（页面结构，图片）后执行。</li>
                <li>jq的入口函数：页面结构加载完毕后执行。</li>
            </ul>
        </li>
        <li>$是jq所暴露出来的一个全局变量;jQuery 是jq暴露的第二个全局变量,一般不使用，通常使用$的用法。($ === jQuery)
            <ul>
                <li>1 $("#btn1")  选择器功能</li>
                <li>2 $(function(){       })   入口函数功能</li>
                <li>3 $(document) 赋予原生js的dom对象以新的功能（加强）</li>
            </ul>
        </li>

    </ul>
    <h4>js对象与jq对象</h4>
    <ul>
        <li>DOM对象：js中原生提供的方法获取的dom元素;jq对象：通过jq的获取方式获取到的对象，称为jq对象</li>
        <li>jq的方式获取的jq对象实际上是将原生的DOM对象进行了包装，再赋予新的功能,也称jq对象实际上是dom对象的包装集</li>
        <li>导致的特性，dom对象与jq对象的功能相互独立：dom对象只能使用dom的属性和方法;jq对象也只能使用jq提供的属性和方法</li>
        <li>将dom对象转换为jq对象（使用$()进行包裹即可）</li>
        <li>将jq对象(一个数组)转换为dom对象（取出jq对象内部的dom对象）dom=jq[0]</li>
    </ul>
    <h4>jq选择器</h4>
    <ul>
        <li>1 标签选择器:  $("标签名")</li>
        <li>2 id选择器:  $("#id名");</li>
        <li>3 类选择器：  $(".类名");</li>
        <li>4 交集选择器:$("p.box")</li>
        <li>5 并集选择器: 使用逗号分割，一次选取多种标签:$("div.box,p")</li>
        <li>6 层级选择器
            <ul>
                <li>1 子代选择器   >标识 $("ul>li")</li>
                <li>2 后代选择器  空格标识  $(".list li")</li>
            </ul>
        </li>
        <li>
            基本选择器
            <ul>
                <li>:even 获取到索引值为偶数的元素</li>
                <li>:odd 获取到索引值为奇数数的元素</li>
                <li>:eq(索引值) 按照索引值=获取某一个元素</li>
            </ul>
        </li>
        <li>
            过滤选择器：都是方法的书写形式。好处：灵活性强，完善链式编程的书写方式。
            <ul>
                <li>children() 获取子元素中的某些指定元素</li>
                <li>find() 找到后代中满足条件的元素</li>
                <li>parent()  获取父元素，注意与parentNode的区别，可能获取到多个元素</li>
                <li>siblings() 同级元素</li>
                <li>eq(索引值)</li>
                <li>next() 获取后一个同级元素</li>
                <li> prev() 获取前一个同级元素</li>
            </ul>
        </li>
    </ul>
    <h4>jq的两大特性</h4>
    <ul>
        <li> 隐式迭代(遍历)：当我们使用jq获取了多个元素时不需要遍历，直接对进行对象进行操作;操作会应用与内部获取到的所有dom对象上</li>
        <li> 链式编程：当执行过任意的设置型操作后，均可继续操作原有对象</li>
        <li> 隐式迭代操作同样只对设置型操作有效果，对获取操作无效（原因是无法减少操作的步骤）</li>
    </ul>
    <h4>jq方法</h4>
    <ul>
        <li>index() 可以获取在同级元素中的索引值</li>
        <li>css方法用于进行样式的操作
            <ul>
                <li>设置操作 : 样式名可以使用驼峰命名法和css的形式，但是推荐使用驼峰命名的方式;如果样式的值需要单位，单位可加可不加</li>
                <li>css方法可以一次进行多个样式的修改：传入一个对象</li>
                <li> 获取样式的值:$("#box").css("width");获取时，只能传入一个参数，如果是带单位的样式，结果具有单位，字符串格式</li>

            </ul>
        </li>
        <li>显示使用show();隐藏使用 hide();</li>
        <li>
            移入事件: mouseover()会产生冒泡    mouseenter()不会产生冒泡;移出事件: mouseout() 会产生冒泡    mouseleave()不会产生冒泡
        </li>
    </ul>
</div>
<div>
    <h2>第二十天jq类名操作丶动画与节点操作</h2>
    <h4>类名操作</h4>
    <ul>
        <li>添加类名: addClass()</li>
        <li>移除类名: removeClass();移除时不需要考虑设置时的书写顺序</li>
        <li>切换类名: toggleClass();检测，传入的类名是否存在，如果有，移除，如果没有，添加</li>
        <li>检测是否拥有类名:hasClass(); 返回bool值
            <ul>
                <li>检测单个标签的单个类名(推荐的用法)</li>
                <li>检测单个标签的多个类名(通常不会进行多个类名的同时检测，除非可以确定类名书写的顺序否则，即便书写正确，但是位置不对，依然返回false)</li>
                <li> 多个标签的类名检测:检测时，多个标签中只要某个标签具有对应的样式，返回true，不准确</li>
            </ul>
        </li>
    </ul>
    <h4>三组jq自动动画与自定义动画</h4>
    <ul>
        <li>
            show()和hide();
            <ul>
                <li>不传入参数表示显示，没有运动</li>
                <li>参数1，表示运动时间，毫秒为单位;参数1 允许传入字符串:  "fast"200  "normal"400  "slow"600;</li>
                <li>如果传入的字符串为其他内容，默认为"normal"400毫秒。</li>
                <li>运动时修改的样式为宽 高 透明度</li>
                <li>参数2 回调函数，内部的代码会在运动完毕后执行</li>

            </ul>

        </li>
        <li>
            slideDown()滑入（拉下来）和slideUp() 滑出（上拉）;slideToggle()切换
            <ul>
                <li>参数1 表示运动时间，如果不传，默认为400毫秒;传入的形式可以为 毫秒的数值 或者 3种字符串</li>
                <li>参数2 回调函数，运动完毕后执行</li>
             </ul>
        </li>
        <li>
            fadeIn() 渐入；fadeOut()渐出；fadeToggle()  切换；fadeTo();渐到什么程度，参数为透明度，通常我们不推荐使用这个方法，原因是，会对其他的运动操作造成影响
        </li>
        <li>animate();
            <ul>
                <li>参数1 必选 要进行运动的样式以及运动到的值 , 对象形式</li>
                <li>参数2 可选 运动时间:可以为毫秒或者字符串形式</li>
                <li>参数3 可选 运动模式 默认为"swing" 缓动 , 可设置为"linear" 匀速</li>
                <li>参数4 可选 回调函数:运动结束执行</li>

            </ul>
        </li>
        <li>stop();
            <ul>
                <li>参数1 是否清除动画队列  true表示清除，false表示不清除</li>
                <li>参数2 是否跳到当前动画的最终效果  true表示跳到最终效果  false不跳</li>
                <li>两个参数的默认值均为false;false,false 最终需要的效果,最常用</li>
            </ul>
        </li>
    </ul>
    <h4>节点操作</h4>
    <ul>
        <li> 创建元素的方式:
            <ul>
                <li>1 $("标签");</li>
                <li>2 指定某个标签内内部结构创建:html()相当于innerHTML,$("#box").html("标签");</li>
            </ul>
        </li>
        <li>
            4中基本的节点移动方式
            <ul>
                <li>append():与原生的appendChild的区别:如果添加的位置具有多个，可以同时添加到多个位置(dom方法不可以)</li>
                <li>prepend() 添加位置为元素的子节点最前面</li>
                <li>after() 向同级元素的前添加</li>
                <li>before() 向同级元素的后添加</li>
                <li>对应的4种：区别在于是当前调用方法的元素加到方法里面元素中；目的是为了完善链式编程的用法。
                    <ul>
                        <li>appendTo();</li>
                        <li>prependTo();</li>
                        <li>insertAfter();</li>
                        <li>insertBefore();  跟dom中的insertBefore完全无关</li>
                    </ul>
                </li>

            </ul>
        </li>
        <li>移除节点
            <ul>
                <li>想要删除box内部的元素,$("#box").html("");这写标签的结构被删除掉了，实际上如果内部元素具有事件，这时事件无法移除。</li>
                <li>empty() 可以移除标签内部的所有内容  ( 感觉被掏空 )</li>
                <li>想要删除当前元素内部内容以及自身  remove()  ( 自杀 ) detach() 不能删除事件</li>
            </ul>
        </li>
    </ul>
    <p>
        动画队列:当一个一个运动没有完毕时，立刻添加一个新的动画， 这时旧的动画会继续执行，新的动画需要进行等待.会导致动画的积累，这种效果称为动画队列
    </p>
</div>
<div>
    <h2>第二十一天 事件</h2>
    <h4>属性和样式操作</h4>
    <ul>
        <li>attr方法用于操作标签的行内属性（自定义属性 获取某些自带属性时取值不准确：类似disabled等属性的值为非bool值)</li>
        <li>prop方法用于操作标签的行内属性（自带属性）无法操作自定义属性</li>
        <li>样式获取操作：
            <ul>
                <li>通过css的方式获取样式值：宽</li>
                <li>$("#box").width() 获取宽度的数值，数值类型 只含有width的值</li>
                <li>innerWidth() 数值类型  含 width + padding</li>
                <li>outterWidth() 含  width + padding + border</li>
                <li>outterWidth(true)  含  width + padding + border + margin</li>
            </ul>
            样式设置操作：
            <ul>
                <li>width()只有width修改</li>
                <li>$("#box").innerWidth(200);修改的是width + padding的总和    修改的具体值为width的值</li>
                <li>$("#box").outerWidth(200);修改的是width + padding + border 的总和    修改的具体值为width的值</li>
                <li>修改的是width + padding + border +margin 的总和  修改的具体值为width的值;传参方式：先传数，再传true</li>

            </ul>
        </li>

    </ul>
    <h4>scroll,offset,opsition</h4>
    <ul>
        <li>scrollTop() 卷曲高度;scrollLeft()  卷曲宽度</li>
        <li>使用offset()可以得到一个对象值
            <ul>
                <li>是相对于页面的,与原生js的offset系列属性有所不同</li>
                <li>设置offset值时需要使用对象的形式，并且设置的值必须是数值类型</li>
                <li>如果元素没有设置定位，默认方法会给元素添加一个相对定位（不要让方法去加，自己设置即可）</li>
            </ul>
        </li>
        <li>position() 获取的样式值是参考定位的父盒子的值
            <ul>
                <li>获取的结果与offsetLeft等 略有不同，取得的值不会包含margin的值</li>
                <li>无法设置，只读(下面的代码不会生效)</li>
                <li></li>
            </ul>
        </li>

    </ul>
    <h2>事件的</h2>
    <ul>
        <li>使用bind方法管理;$("#btn").bind("click mouseenter mouseleave",function () {}),参数可以是对象</li>
        <li>delegate()  可以添加事件委托 事件代理 $("#box").delegate("p,span","click",function () {})</li>
        <li>最终jq使用on()统一了所有的事件添加方式
            <ul>
                <li>1 简单事件添加;$("#btn").on("click",function () {}).参数可以是对象</li>
                <li>2 添加多个事件;$("#btn").on("click mouseenter mouseleave",function () {//多个事件共用一个处理程序})</li>
                <li>3 事件委托的方式 注意参数传递顺序：  参数1 事件类型  参数2 指定哪些内部元素可以触发  参数3 事件处理程序</li>
                <li>$("#box").on("click", "p,span", function () {//将事件委托的box，而不是直接添加给内部的子元素})</li>
            </ul>
        </li>
        <li>事件委托先执行，然后在执行box自身设置的事件</li>
        <li>
            事件的取消
            <ul>
                <li>1 移除指定事件(移除各种各样的指定事件) $("#box").off("click");</li>
                <li>1.1 如果想要移除指定事件类型中的某一个事件，可以传入参数2，事件处理程序 $("#box").off("click", fun);</li>
                <li>1.2 移除事件委托 $("#box").off("click","**");</li>
                <li>2 同时移除多种事件 $("#box").off("click mouseenter");</li>
                <li>3 移除box的所有事件 $("#box").off();</li>
            </ul>
        </li>
        <li>
            事件的触发方式
            <ul>
                <li>手动触发点击事件 $("#btn").click();</li>
                <li>使用trigger方法触发某个事件，与基本的触发方式大体相同 $("#btn").trigger("click");（标准的触发方式，会执行事件代码以及触发事件执行的页面显示效果）</li>
                <li>$("#btn").triggerHandler("click"); 只会触发代码的执行， 不会出现页面显示上的变化</li>
             </ul>
        </li>
        <li>取消事件传播(jq中的使用方式：)
            <ul>
                <li>e.preventDefault();//可以取消标签的默认事件效果</li>
                <li>e.stopPropagation();//阻止事件传播</li>
                <li>return false;可以取消标签的默认事件效果，同时可以阻止事件的传播</li>
                <li>return false在js中只能取消标签的默认事件效果.</li>

            </ul>
        </li>
    </ul>
    <h4>其他</h4>
    <ul>
        <li>e.keyCode获取按键对应的值</li>
        <li>多库共存
            <ul>
                <li>jq具有不同的版本，新版本的功能的效率基本上都高于低版本。;有的时候由于浏览器版本的限制，不得不使用旧版本。</li>
                <li>如果一个页面需要在多种浏览器上使用，可能根据使用的浏览器不同，使用的版本也不同。</li>
                <li>$.fn.jquery 该属性可以查看jq的版本号</li>
                <li>var $2 = $.noConflict() jq内部提供了一个方法，可以放弃jq对$的控制权，返回值为jq的使用权,我们可以将使用权赋予全新的一个变量。</li>
            </ul>
        </li>
        <li>图片懒加载插件</li>
        
    </ul>
    <h5>js文件第一行加 use strict 开启严格模式</h5>
</div>
</body>
</html>