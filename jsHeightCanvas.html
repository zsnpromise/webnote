<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>js高级</title>
	 <style>
        p {
            width: 100%;
        }
    </style>
</head>
<body>
	<div>
          <h2>JavaScript 高级 (6.10)</h2>
          <h4>相关资料推荐</h4>
          <ul>
          	<li>MDN-JavaScript: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></li>
          	<li>JavaScript 高级程序设计（第3版）建议平时有空就看,看书看到的是自己的</li>
          	<li>JavaScript 语言精粹 编写可维护的 JavaScript </li>
          	<li>你不知道的 JavaScript 上 中 下</li>
          	<li>JavaScript 权威指南 稍微有点儿难度</li>
          	<li>JavaScript 面向对象编程指南（第2版） JavaScript 面向对象精要</li>
          </ul>
          <h3> 二 基本概念复习</h3>
          <h4>JavaScript 是什么？</h4>
          <ul>
          	<li>JavaScript ( JS ) 是一种轻量级解释型的，或是 JIT 编译型的程序设计语言
                <ul>
                	<li>解释型：可以在执行阶段为变量赋值和修改数据类型</li>
                	<li>编译型：程序在执行之前就已经确定了类型，一旦定义类型，不可改变</li>
                	<li>后来一些 JavaScript 解析引擎为了提高 JavaScript 执行效率，引入了 JIT 即时编译器</li>
                	<li>执行之前先预编译，然后再执行的过程中再去动态解析</li>
                </ul>
          	</li>
          	<li>在 JavaScript 语言中最大的特色是什么？
              <ul>
              	<li>函数是一等公民</li>
              	<li>普通函数 构造函数 Object() Function() 当做参数来传递 函数自调用 当做返回值</li>
              	<li>apply、call、bind </li>
              	<li>函数内部的上下文 this 的指向  函数也对象</li>
              	
              </ul>
          	</li>
          	<li>有着 函数优先 (First-class Function) 的编程语言。</li>
          	<li>运行与浏览器，浏览器是 JavaScript 代码的执行环境或者说平台</li>
          	<li>JavaScript 除了可以运行在浏览器，也可以运行在别的环境</li>
          	<li>虽然它是作为开发web页面的脚本语言而出名的，但是在很多非浏览器环境中也使用JavaScript，例如 node.js 和 Apache CouchDB。</li>
          	<li>JS是一种基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格。了解更多 关于JavaScript。
              <ul>
              	<li>面向对象 new Object()</li>
              	<li>原型</li>
              	<li>函数式编程 $('selector').css().html().on().css()...</li>
              </ul>
          	</li>
          	
          </ul>
          <h4>JavaScript 的组成</h4>
          <ul>
          	<li>JavaScript 中的组成，需要看 JavaScript 在哪个环境执行</li>
          	<li>如果 JavaScript 是运行在浏览器中：
             <ul>
             	<li>浏览器一般有两个引擎:渲染引擎;解析执行 JavaScript 代码的引擎</li>
             	<li>JavaScript 语言本身</li>
             	<li>浏览器环境为 JavaScript 提供的编程接口 BOM DOM</li>
             </ul>
          	</li>
           </ul>
           <h4>JavaScript 可以做什么</h4>
           <ul>
           	<li>语言本身:条件判断;函数;数组、对象、。。。循环。。</li>
           	<li>特定执行环境(浏览器):使用浏览器提供的编程接口;BOM DOM Ajax;地理定位;Web 存储</li>
           </ul>
           <h4>JavaScript 与 EcmaScript 的关系</h4>
           <ul>
           	<li>EcmaScript 是 JavaScript 的规范;各大浏览器厂商根据标准规范去做出相应的实现</li>
           	<li>JavaScript 是 EcmaScript 的实现 <ul>
           		<li>所以各大浏览器会有实现上的差异</li>
           		<li>Chrome 的 V8 解析引擎目前是公认的最快的</li>
           		<li>Node.js 也是基于 Chrome 的 V8 引擎制造的</li>
           	</ul></li>
             </ul>
             <h4>JavaScript 数据类型</h4>
             <ul>
             	<li>在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。 JavaScript 变量可能包含两种不同数据类型的值：</li>
             	<li>JavaScript 中的基本类型（也叫作值类型）：
                   <ul>
                   	<li>Undefined</li>
                   	<li>Null</li>
                   	<li>Boolean</li>
                   	<li>Number</li>
                   	<li>String</li>
                   </ul>
             	</li>
             	<li>JavaScript 中的复合类型（引用类型）：
                 <ul>
                 	<li>Object Array Date RegExp Function</li>
                 	<li>基本包装类型 Boolean Number String</li>
                 	<li>单体内置对象 Global Math</li>
                 </ul>
             	</li>
             	<li>类型检测:typeof(简单类型) instanceof（数组）Object.prototype.toString.apply(引用类型)</li>
             </ul>
             <h4>基本类型与引用类型的差别</h4>
             <ul>
             	<li>基本类型在内存中占据固定大小的空间，因此被保存在栈内存中</li>
             	<li>从一个变量向另一个变量复制基本类型的值，复制的是值的副本</li>
             	<li>引用类型的值是对象，保存在堆内存</li>
             	<li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针</li>
             	<li>从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象</li>
             </ul>
             <h4>面试题：深拷贝与浅拷贝</h4>
             <ul>
             	<li>面试题目 1：var a = {"x": 1};var b = a;a.x = 2;console.log(b.x);a = {"x": 3};console.log(b.x);a.x = 4;console.log(b.x);</li>
             	<li>面试题目 2：var a = {n: 1};var b = a;a.x = a = {n: 2};console.log(a.x);
console.log(b.x);</li>
            
             </ul>
             <h4>JavaScript 运算符优先级</h4>
             <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN - 运算符优先级</a>
          <h3>三 JavaScript 面向对象编程</h3>
          <h4>什么是面向对象:</h4>
          <ul>
          	<li><a href="https://www.zhihu.com/question/19854505" target="_blank">知乎：如何用一句话说明什么是面向对象思想？</a></li>
          	<li><a href="https://www.zhihu.com/question/31021366" target="_blank">知乎：什么是面向对象编程思想？</a></li>
          	<li>面向对象与面向过程：<ul>
          		<li>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊</li>
          		<li>面向对象就是找一个对象，指挥得结果</li>
          		<li>面向对象将执行者转变成指挥者</li>
          		<li>面向对象不是面向过程的替代，而是面向过程的封装</li>
          	</ul></li>
          	<li>面向对象的特性：抽象性;封装性;继承性;[多态性]</li>
          </ul>
          <h4>JavaScript 是不是一个面向对象的编程语言？</h4>
          <ul>
          	<li>不是:相对于传统的语言：Java、C#、C++ 之类的语言，JavaScript 中没有类的概念</li>
          	<li>是:JavaScript 里面也可以使用 new 语法来创建实例化对象，而且基本上都是对象：Object、Array、RegExp。。。</li>
          	<li>到底是什么:JavaScript 是一个多范式编程语言;面向过程;面向对象;函数式编程</li>
          </ul>
          <h4>什么是对象</h4>
          <ul>
          	<li>在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集</li>
          	<li>ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。 严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都 映射到一个值。</li>
          	<li>提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</li>
          	<li>总结：对象是一组键值对;对象本身就是封装的一种体现</li>
          </ul>
          <h4>创建对象</h4>
          <ul>
          	<li>原始模式的改进：工厂模式;通过工厂模式解决了创建多个相似对象代码冗余的问题， 但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</li>
          	<li>工厂模式的改进：构造函数 </li>
          	<li>使用 constructor 属性可以用来确认实例和构造函数之间的关系,实例对象都具有一个 constructor 属性，可以获取创建该实例的构造函数  实例的 constructor 属性不严谨，推荐使用 instanceof 操作符</li>
          	
          </ul>
          <h4>原型对象 prototype</h4>
          <ul>
          <li>原型与继承:对构造函数来说，原型对象是它的一个属性。
对实例来说，原型对象是它的原型</li>
<li> 原型对象的一个应用:通过修改原型对象扩展原生构造函数内置方法</li>
          	<li>实例对象无法修改原型对象中的普通类型数据</li>
          	<li>如果实例去修改原型对象中的引用类型数据，就真的修改了</li>
          	<li>建议：将普通数据放到构造函数中，将函数放到原型中</li>
          	<li>__proto__属性为非标准属性，因此具有兼容问题</li>
          </ul>
          <h4>补充知识</h4>
          <ul>
          	<li>isPrototypeOf() 该用来判断，某个 proptotype 对象和某个实例之间的关系</li>
          	<li>hasOwnProperty()每个实例对象都有一个 hasOwnProperty() 方法，用来判断某一个属性到底是本地属性，还是继承自 prototype 对象的属性 </li>
          	<li>in 运算符 in 运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性</li>
          	<li>自定义校验某个属性是否属于原型属性： hasProtypeProperty()</li>
          </ul>
          <h4>附录 A 代码规范</h4>
          <ul>
          	<li>代码风格
             <ul>
             	<li><a href="https://github.com/feross/standard">JavaScript Standard Style</a> </li>
             	<li><a href="https://github.com/airbnb/javascript">Airbnb JavaScript Style Guide() </a> </li>
             </ul>
          	</li>
          	<li> 校验工具 <ul>
             	<li><a href="https://github.com/douglascrockford/JSLint">JSLint</a> </li>
             	<li><a href="https://github.com/jshint/">jshint</a> </li>
             		<li><a href="https://github.com/eslint/eslint">ESLint</a> </li>
             </ul></li>
          </ul>
          <h4>附录 B Chrome 调试工具的使用</h4>
          <ul>
          	<li>调试面板各大功能菜单栏介绍</li>
          	<li>Elements  选择元素：Ctrl + Shift + c;切换设备：Ctrl + Shift + m</li>
          	<li>Console JavaScript REPL</li>
          	<li>Sources 查看网站资源文件资源 使用 Chrome 的 Sources 作为编辑器;在 Sources 面板按下 ESC 键可以查看切换 Console</li>
          	<li>Network 查看网络请求</li>
          	<li>Timeline 代码执行时间线</li>
          	<li>Profiles 查看分析网页性能</li>
          	<li>Application 查看执行环境资源，例如本地存储、Web 缓存、Web 数据库 等</li>
          	<li>Security Audits</li>
          	<li>断点调试
                 <ul>
                 	<li>设置断点:在具体代码的行号位置的侧边栏单击变为蓝色的标记;注意观察右侧 Breakpoints 可以管理我们设置的断点;启用和关闭所有断点：Ctrl + F8</li>
                 	<li>逐步执行:快捷键：F11 或者 Ctrl + ;浅蓝色表示已经执行过了，淡蓝色表示即将执行</li>
                 	<li>变量监视:右键变量 -> Add to watch;在 Watch 面板中添加要监视的成员</li>
                 	<li>逐过程执行:遇到普通语句和逐步的效果是一样的;遇到函数调用会跳过函数执行过程</li>
                 	<li>继续执行:遇到断点会挺住，否则直接执行结束</li>
                 	<li>条件断点</li>
                 </ul>
          	</li>
          </ul>
          <h4>附录 C 文档相关工具</h4>
          <ul>
          	<li>Markdown <a href="https://guides.github.com/features/mastering-markdown/">https://guides.github.com/features/mastering-markdown/</a><br>
          	<a href="https://github.github.com/gfm/">https://github.github.com/gfm/</a></li>
          	<li>电子书制作工具 <a href="https://github.com/QingWei-Li/docsify">https://github.com/QingWei-Li/docsify</a><br>
          	<a href="https://github.com/egoist/docute">https://github.com/egoist/docute</a></li>
          	<li>流程图工具：DiagramDesigner <a href="http://logicnet.dk/DiagramDesigner/">http://logicnet.dk/DiagramDesigner/</a></li>
          </ul>
          <h4>附录 D Markdown</h4>
          <ul>
          	<li>更加专注于写作，尤其程序员最喜欢用，表示代码很方便 类似于 HTML 的标记语言</li>
          	<li><a href="http://www.jianshu.com/p/q81RER" target="_blank">简书 - 献给写作者的 Markdown 新手指南</a></li>
          	<li><a href="http://wowubuntu.com/markdown/" target="_blank">Markdown 语法说明</a></li>
          	<li>leanote 写作工具</li>
          </ul>
          <h4>6.10目标</h4>
          <ul>
          	<li>1. 列举 JavaScript 中的普通数据类型和引用数据类型</li>
          	<li>普通数据类型：underfined,boolean,string,null,number 引用数据类型:Object Array Function  Date regExp</li>
          	<li>3. 概述基本类型和引用类型的差异并举例</li>
          	<li>基本类型在栈上存储值，引用类型在栈上存储值在堆上的引用的引用。</li>
          	<li>4. 概述什么是深拷贝和浅拷贝并举例</li>
          	<li> 深拷贝是通过循环和递归的手段对一个对象进行拷贝，新的对象与被拷贝的对象之间完全没有关系。浅拷贝只是单纯的通过循环被拷贝的对象的属性给新对象，如果被拷贝对象存在引用类型的属性，那么新对象的
   该属性和被拷贝对象的属性指向堆中的同一个内存地址。</li>
          	<li>5. 实现一个深度拷贝方法
             <p> function extend(obj,callObj){ callObj=callObj||{}; <br>
        for(var k in obj){  <br>
            if(Object.prototype.toString.call(obj[k])=="[object Object]") <br>
            {
                callObj[k]= arguments.callee(obj[k],{});
            } <br>else {
                callObj[k]=obj[k];
            }
        }
        return callObj;
    }</p>
          	</li>

          	<li>6. $.extend() 方法的使用
               <ul>
               	<li>浅拷贝用法  $.extend(obj, obj1, obj2);</li>
               	<li>深拷贝用法 $.extend(true, obj, obj1, obj2);</li>
               	<li>第一个参数要嘛给 true ，要嘛什么都不给 var returnVal = $.extend(false, obj, obj1, obj2);</li>
               	<li>jQuery.extend([deep], target, object1, [objectN])</li>
               	<li>target:一个对象，如果附加的对象被传递给这个方法将那么它将接收新的属性，如果它是唯一的参数将扩展jQuery的命名空间。object1:待合并到第一个对象的对象。objectN:待合并到第一个对象的对象。



</li>
               </ul>
          	</li>

          	<li>7. 普通数据类型检测和引用数据类型检测</li>
          	<li>普通数据类型:typeof 数组： instanceof  引用数据类型:Object.prototype.toStringApply()</li>
          	<li>8. 为系统内置构造函数添加原型方法</li>
          	<li>String.prototype.endStr=function(str){var reg=new RegExp(str+"$"),bl=false;
   <br> if(reg.test(this)) {bl=true;}return bl;}</li>
          	<li>9.jqery函数式编程
               <ul>
               	<li>function myJquery(target){ return new myJquery.prototype.inir(target);}</li>
               	<li> myJquery.prototype.inir.prototype=myJquery.prototype;</li>
               	<li>myJquery.prototype.inir=function(target){ var targets=  document.querySelectorAll(target);for (var i = 0; i < targets.length; i++) { this[i]=targets[i];} this.length=targets.length;}</li>
               
               </ul>
          	</li>
          	<li>10. 函数可以生成函数  function genCheckType(type) {return function (obj) {
     return Object.prototype.toString.apply(obj) === type}}</li>
          </ul>
          <h5>字符串方法： search 是强制正则的，而 indexOf 只是按字符串匹配的。match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</h5>
	</div>
	<div>
      <h2>面向对象封装，jq插件，深复制（6.11）</h2>
      <h4>今日目标</h4>
      <ul>
      	<li> 1. 概述构造函数-实例-原型对象 三者之间的关系并举例
      		<p>对于构造函数来说，原型对象就像是它的属性，原型对象中有一个属性指向构造函数。实例对象是通过构造函数创建的。实例对象中有一个属性—_proto_(该属性是非标准的属性)指向原型对象。</p>
      	</li>
      	<li>2. 概述什么是原型链以及对象属性的搜索原则并举例
      		<p>在js中，继承的实现体现在原型链中，当前对象的_proto_属性指向该对象的原型，而该对象的原型又有_proto_指向更上一级的原型
对象，直到_proto_属性指向null才结束。对象调用属性的时候，先在自身，如果没有，则沿着原型链一步步向上，如果找到就直接返回，
直到 Object.prototype.__proto__ 发现为 null 的时候，最后返回 undefined。就像dom对象的prototype。</p>
      	</li>
      	<li>3. 概述封装面向对象版标签页实现的演变过程
      		<p></p>
      	</li>
      	<li>4. 举例说明函数也是对象
      		<p>使用操作符Object.prototype.toString.call()返回"[object Function]"说明函数是函数对象，并且可以给函数添加属性，
并且通过函数名.属性可以进行调用。</p>
      	</li>
      	<li>
      		<p>5. 理解 jQuery 插件机制</p>
      	</li>
      	<li>
      		<p>6. 模拟实现一个 `$.extend()` 方法</p>
      	</li>
      </ul>
     <h4>函数优先级</h4>
     <ul>
     	<li>function Foo() {getName = function () {alert(1);};return this;}</li>
     	<li>Foo.getName = function () {this.foo = 'bar'; alert(2);};</li>
     	<li>Foo.prototype.getName = function () {alert(3);};</li>
     	<li>var getName = function () {alert(4);}; function getName() {alert(5);}</li>
     	<li>问：new Foo.getName();new Foo().getName();new new Foo().getName();</li>
     	<li>第三个解析：new ((new Foo()).getName)();</li>
     </ul>

    
	</div>

	<div>
  <h2>函数继承 （6.13）</h2>
      <h4>函数概念</h4>
      <ul>
      	<li>构造函数如果有返回值，则以引用类型为主</li>
      	<li>函数的三种角色：普通函数，构造函数，对象</li>
      	<li>把函数当作对象来使用，就必须只能通过 函数.成员 来访问</li>
      	<li>只要是通过 new 操作符来调用 Person 函数,则该函数在执行的的时候:
             <ul>
             	<li>1. 先创建一个新的对象 var o = {}</li>
             	<li>2. 将该函数内部的 this 指向 o ： this = o</li>
             	<li>3. 接下来开发人员就可以直接使用 this 来初始化 o 对象成员</li>
             	<li>4. 在函数的最后，默认隐式的 return this</li>
             </ul>
      	</li>
      	<li>什么是构造函数？
            <ul>
            	<li>从语法上，new 函数名() 就会把该函数当作构造函数来调用; 构造函数用来构建创建具体的对象的</li>
            	<li>为什么需要构造函数或者说构造函数解决什么问题？ 解决对象创建的问题; 语法简洁了;其次可以判断实例对象的类型了</li>
            	
            </ul>
      	</li>
      </ul>
      <h5>
      函数的 call 方法可以用来调用函数的同时，通过第一个参数改变内部 this 指向,需要传递参数，则可以从第二个参数开始以 , 作为分隔传递给函数</h5>
     
      <h4> 为什么通过匿名函数自执行把 window 传递进去</h4>
      <ul>
      	<li>从程序执行效率来讲：目的是为了减少内部的作用域查找范围</li>
      	<li>从代码依赖角度来讲：把相关的依赖项单独传递给匿名函数内部</li>
      	<li>这样做的目的是为了让模块的依赖更明确</li>
      </ul>
      <h4>数组some方法</h4>
      <ul>
      	<li> some 也是遍历数组，只不过它会针对函数的返回值得到不同的结果</li>
      	<li>如果在遍历的过程中某个函数返回了 true ，则 some 方法返回 true</li>
      	<li>如果一直遍历到结束，都没有函数返回 true，则 some 方法返回 false</li>
      	<li> var result = arr.Some(function (num, index) {return num % 2 === 0})</li>
      </ul>
        <h5>为什么需要对象?如果没有对象，可能就会有一大堆的全局变量;对象也叫命名空间;将一些相关数据放到一起，方便整理和维护;进行数据传递时，传递对象更加的方便</h5>
        <h5>jq:$(function(){}),方法的实现</h5>
        <h4>自己模拟实现 `map` `every` `filter`</h4>
        <ul>
        	<li>Array.prototype.map()方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li>
        	<li>every() 方法测试数组的所有元素是否都通过了指定函数的测试(与some的区别是some只要有一个成立，立马返回true)</li>
        	<li>filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</li>
        </ul>
       <h3>继承二法</h3>
       <ul>
       	<li>第一种：组合遍历法 可以通过call继承父类的属性，通过循环遍历父类的prototype继承父类的方法（根据需求进行深赋值或浅复制）</li>
       	<li>第二种：组合寄生继承 可以通过call继承父类的属性,通过寄生的方式继承父类原型的方法
           <ul>
           <li>如果直接让子类的原型对象成为父类的实例，缺点是会继承父类的属性，所以采用一个中转构造函数，采用寄生的方式间接使子类的原型对象成为父类的实例</li>
           <li>如果直接让子类的原型对象指向父类的原型对象，修改子类constructor会把父类的也修改</li>

           	<li> function object(obj) {function F(){};F.prototype=obj;return new F();}</li>
           	<li>function inHeritPrototype(target,selector) {var prototype=object(selector);prototype.constructor=target;target.prototype=prototype;}</li>
           	<li><img width="400" src="img/组合寄生继承.png" alt=""></li>
           </ul>
       	</li>
       	<li>相同处：两者都可以继承父类的属性和方法，都是通过Call来继承父类的属性</li>
       	<li>不同点：第一种方法思路更加简单，第二种方法好处在于子类构造函数原型对象_proto_指向了父类的原型对象。</li>
       </ul>
	</div>
	<div>
         <h2>call,apply,bind,贪吃蛇（6.14）</h2>
         <h4>this指向的不同场景</h4>
         <ul>
         	<li>普通函数调用:
               <ul>
               	<li>在非严格模式下，普通函数中的 this 指向 window</li>
               	<li>在严格模式下，普通函数中的 this 是 undefined</li>
               </ul>
         	</li>
         	<li>
           构造函数调用
           <ul>
           	<li>指向实例对象</li>
           	<li>原型方法中的 this 与构造函数调用中的 this 指向相同</li>
           </ul>
         	</li>
         	<li>对象方法调用:指向调用对象，就是方法紧挨着的对象</li>
         	<li>事件绑定方法:指向绑定事件的对象</li>
         	<li> 定时器函数:指向 window</li>
         </ul>
          <h4>call,apply,bind的this指向方法的第一个参数（该参数必须是引用类型）</h4>
          <ul>
            <li>call 和 apply 特性一样
              <ul>
              	<li>都是用来调用函数，而且是立即调用</li>
              	<li>但是可以在调用函数的同时，通过第一个参数指定函数内部 `this` 的指向</li>
              	<li>call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可</li>
              	<li>apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递</li>
              	<li>如果第一个参数指定了 `null` 或者 `undefined` 则内部 this 指向 window</li>
              </ul>
            </li>
            <li> bind
                <ul>
                	<li> 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数</li>
                	<li> 它和 call、apply 最大的区别是：bind 不会调用</li>
                	<li>bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递
                      <ul>
                      	<li>1. 在 bind 的同时，以参数列表的形式进行传递</li>
                      	<li> 2. 在调用的时候，以参数列表的形式进行传递</li>
                      	<li> 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部</li>
                      	<li>函数的 bind 方法传递参数规则： 在 bind 的同时可以预制（预先传递）一些参数，不调用；然后在调用的时候，传递的参数，将会放到预制参数之后进行传递</li>
                      </ul>
                	</li>
                </ul>
            </li>
         
          	<li>针对bind绑定：绑定了 this 环境的 函数，如果使用 new 来调用，则 this 还是指向实例对象</li>
          </ul>
          <h5>面试题：模拟函数内部arguments[0]()调用参数方法 var arr=[function(){console.log(this.length)},2,3];arr[0]()</h5>
          <h5>Underscore.js:类似于jq库，jq操作dom，而它和dom无关，只要作用是对数组，对象一类操作的简化</h5>
	</div>
	<div><h2>贪吃蛇完成(6.16)</h2>
	<h4>原型模式和 借用父类构造函数+拷贝父类原型对象 的区别</h4>
	<ul>
		<li>原型模式继承核心就是利用原型链搜索机制实现继承，每一次访问继承过来的成员的时候都必须通过原型链进行查找，如果原型链太多，会导致效率不高。</li>
		<li>第一次继承的时候的效率高，而后续查找成员的时候效率低。</li>
		<li> 而 借用父类构造函数+拷贝父类原型对象 的方式，是直接将父类的所有成员拷贝到自己身上，每次使用的时候，直接就在自己身上拿到了，相对于原型模式效率更高</li>
		<li> 第一次继承的时候效率低，而后续查找成员的时候效率比原型模式高。</li>
		
	</ul>
    
	</div>
	<div>
       <h2>sea.js模块化（6.17）</h2>
       <h4>模块化解决的问题</h4>
       <ul>
       	<li>通过 script 标签加载 JavaScript 文件还是麻烦</li>
       	<li> 关键在于 JavaScript 脚本文件之间的相互依赖</li>
       	<li>文件越来越多，无法保证变量命名冲突的问题</li>
       </ul>
        <a href="https://seajs.github.io/seajs/docs/">SeaJS在线地址</a>
       <a href="https://github.com/seajs/seajs/archive/master.zip">下载地址</a>
       <h4>sea.js用法即注意事项</h4>
       <ul>
       	<li>引入 sea.js</li>
       	<li> 使用 seajs.use() 方法，指定模块启动入口，然后启动模块运行
            <ul>
            	<li> 提示：入口文件模块最好起名 main.js</li>
            	<li>注意：文件路径一定要以 ./ 或者 ../ 开头;如果不以 ./ 或者 ../ 则会跑到 sea.js 文件路径去查找</li>
            	
            </ul>
       	</li>
       	<li> 在 seajs 中，一个 JavaScript 文件就是一个模块
            <ul>
            	<li> 所有代码写到 define 函数中;所有代码都运行在模块私有作用域</li>
            	<li> define 函数需要接收一个匿名函数作为参数; 该函数参数同时需要接收三个参数：require exports  module</li>
            	<li>注意：参数顺序不能变，包括参数的名字不能改</li>
            </ul>
       	</li>
       	<li>
         使用 require 函数根据指定文件模块路径加载模块,返回加载模块的返回值（函数，对象）
         <ul>
         	<li>模块的后缀名可以省略</li>
         	<li>加载并执行被加载模块的代码</li>
         	<li>返回当前文件模块的值 module.exports= 返回对象（函数，值），赋值给它可以使其它js模块引用当前模块获取返回值</li>
         </ul>
       	</li>
       	<li>define(function (require, exports, module) {  var $ = require('../vendor/jquery-3.2.1')//引入 module.exports = 返回对象;//导出  })</li>
       	<li>jq和underscore不支持sea.js(cmd)，而支持require.js（amd）;要找到对应的define手动加上</li>
       	<li>exports本质上就是module.exports，指向同一个地址。但后者更好用，因为前者不能修改其地址的引用，而后者可以</li>
       </ul>
       <h4>模块进化论</h4>
       <ul>
       	<li>全局函数：容易导致命名空间污染，多个函数之间没有直接关系</li>
       	<li>命名空间：将多个函数放到 cal 对象命名空间中，让他们产生了一定的联系；对象命名空间中全部都暴露出来了，能不能有一种方式，让对象具有私有空间</li>
       	 	<li>私有空间-将对象封装到函数中的作用：
            <ul>
            	<li> 具有了私有空间，公有可以直接挂载到 cal 上即可，私有的直接定义到内部函数作用域即可</li>
            	<li>如果希望外部可以访问内部的私有成员而不允许修改，则可以直接为对象提供一个方法，在方法内部返回当前作用域内部的某个私有成员</li>
            </ul>
       	</li>
       	
       	<li>模块的依赖问题-关于模块的传参：
             <ul>
             	<li>1. 从代码执行效率上来讲，能提高内部作用域查找效率;</li>
             	<li> 2. 从模块维护的意义上来讲，让模块的依赖看起来更明确</li>
             </ul>
       	 </li>
      
       
       </ul>
      
	</div>
	<div>
         <h2>事件,闭包,作用域,伪数组(6.19)</h2>  
         <h4>伪数组</h4>
         <ul>
         	<li> 所有的内置构造函数都继承自 Object.prototype; 也就是说所有数组都具有 Object.prototype 的成员; 注意：这里主要是为了说明：所有普通对象没有 Array.prototype 的方法</li>
         	<li>伪数组是一个类似于数组结构的对象</li>
         	<li> Array.prptotype.slice.call(伪数组, 参数...)</li>
         	<li>简写形式：[].数组方法.call(伪数组, 参数);[].数组方法.bind(伪数组, [参数..])</li>
         	<li>数组和对象的区别
             <ul>
             	<li>一个按键值来访问读取数据;一个按索引来访问读取数据</li>
             	<li>对象没有 length 属性;数组具有 length 属性，而且会随着成员长度的变化而变化</li>
             	<li>什么是伪数组：var obj={0:'a',1:'b',length；2}
             	结构类似于数组的对象，就是伪数组，但是不能使用数组的方法
             	</li>
             	<li>伪数组借用数组方法原理：Array.prototype.myEach = function (callback) { for(var i = 0; i < this.length; i++) { callback(this[i], i)}}</li>
             </ul>
         	</li>
         </ul>
          <h4>函数的其它成员</h4>
          <ul>
          	<li> arguments 实参列表，是一个伪数组</li>
          	<li> arguments 除了是一个伪数组之外，还有一个特殊的属性：callee;callee 指向当前函数本身</li>
          	<li> caller 可以得到该函数的调用者(就是当函数在其它函数中时调用，包裹的函数就是调用者)</li>
          	<li>length 形参的个数</li>
          	<li>name   函数的名称</li>
          </ul>
         
          <h4>预解析</h4>
          <ul>
          	<li>全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高</li>
          	<li>函数内部预解析（所有的变量、函数和形参都会参与预解析）</li>
          	<li>函数只有在调用执行的时候才会预解析</li>
          </ul>
         <h5>闭包的应用练习，js执行机制讲解：任务队列栈（先进先出）</h5>
         <h4>阻止冒泡和默认行为</h4>
         <ul>
         	<li> 使用 return false 阻止事件默认行为，只针对 DOM 0 级事件绑定有效，对 DOM 2 级事件绑定无效</li>
         	<li> 阻止事件冒泡，无论是 0 级 和是 2 级事件绑定都必须使用 e.stopPropagation() 方法</li>
         	<li> 关于阻止事件冒泡，必须使用 e.stopPropagation() 方法</li>
         </ul>
         <h5>自定义事件简单例子；正则音乐播放器例子；递归菜单树例子</h5>
        
	</div>

	<div>
     <h2>canvas(6.21)</h2>
     <h4>canvas基本概念</h4>
     <ul>
     	<li>canvas画布的默认匡高300X150,canvas的宽度和高度不允许使用样式设置，要通过标签属性设置</li>
     	<li>canvas坐标系：原点在左上角，x轴水平向右，y轴垂直向下</li>
     	<li>获取画布: var cas = document.querySelector('canvas'); 获取画图工具: var ctx = cas.getContext('2d');// webgl</li>
     	<li>canvas属性
         <ul>
         	<li>绘制起点：ctx.moveTo(100,100);</li>
         	<li>绘制路径： ctx.lineTo(200,100);线条宽度：ctx.lineWidth = 10; 线宽，默认1px</li>
         	<li>描边 ctx.stroke(); 描边颜色： ctx.strokeStyle = 'red';</li>
         	<li>填充路径： ctx.fill();填充颜色： ctx.fillStyle = 'green';</li>
         	<li>关于路径的闭合：1、closePath自动闭合路径（推荐） 2、手动闭合有可能会缺角，解决办法就是多绘制一个点</li>
         	<li>线末端类型(butt默认)： ctx.lineCap = 'square'（比起默认来等于在线条两头各加了一个方块）; ctx.lineCap = 'round'（比起默认来等于在线条两头各加了一个半圆）;</li>
         	<li>相交线的拐点(miter默认)：ctx.lineJoin = 'bevel';（横切，默认直角被切平）ctx.lineJoin = 'round';（直角变圆角）</li>
         	<li>开启新的路径(保证不同的路径样式不同):ctx.beginPath();</li>
         	<li> 虚线绘制 <ul>
         		<li>设置虚线： ctx.setLineDash([5,10,15,20]);可以设置任意多个，按照设置的长度一个虚线一个空白循环显示</li>
         		<li>获取虚线宽度集合：ctx.getLineDash() 奇数获取两组一样的，偶数获取一组。</li>
         		<li>设置虚线偏移量（负值向右偏移） ctx.lineDashOffset = -3;</li>
         		
         	</ul></li>
         	<li>状态的保存与恢复
             <ul>
             	<li>save() 作用就是保存当前环境（上下文），本质上就是保存当前的一些样式设置</li>
             	<li>restore() 恢复最近一次保存的环境</li>
             	<li>可以保持多个当前环境采用的是栈stack(后进先出)的模式</li>
             
             </ul>
         	</li>
         </ul>
     	</li>
     	<li>非零环绕规则
            <ul>
            	<li>路径围住的所有区域，从任何一个区域内部向外拉出一条直线</li>
            	<li>如果该直线穿过的线条数量为奇数条，那么一定会填充</li>
            	<li>如果该直线穿过的线条数量为偶数条，并且方向相反的线条条数相同的话就不填充</li>
            	<li></li>
            </ul>
     	</li>
     	<li>canvas绘制一个像素实际上用的连个像素来表示，对于斜线来说，也是用两个像素表示，但是重合了一个像素，所以看上去比较浅</li>
     	<li>canvas画布可以理解为两个尺寸：标签尺寸、画布尺寸
          <ul>
          	<li> 通过标签内部的属性设置宽高，那么这两种尺寸都会被设置</li>
          	<li>  如果通过样式设置宽高，那么只会设置元素尺寸，浏览器会自动拉伸画布去适应标签尺寸</li>
          	<li>画布尺寸：ctx.canvas.width</li>
          
          </ul>
     	</li>
     	
     </ul>
     <h5>绘制折线图，颜色渐变等练习</h5>
	</div>
  <div>
        <h2>饼状图(6.22)</h2>
         <h4>矩形</h4>
         <ul>
           <li>画一个矩形的路径（没有独立路径）：ctx.rect(x,y,width,height);ctx.stroke();</li>
           <li>画一个描边矩形（有独立路径，不影响别的绘制）：ctx.strokeRect(x,y,width,height);</li>
           <li>画一个填充矩形（有独立路径，不影响别的绘制）：ctx.fillRect(x,y,width,height);</li>
           <li>清除画布一块区域：ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);</li>
          </ul>
          <h5>线性渐变</h5>
          <ul>
            <li>var gradient = ctx.createLinearGradient(0,0,0,100); gradient.addColorStop(0,'red'); gradient.addColorStop(1,'pink'); ctx.fillStyle = gradient;</li>
            <li>径向渐变 ctx.createRadialGradient()</li>
          
          </ul>
            <h4>圆弧绘制（radian 弧度;angle 角度）</h4>
            <ul>
              <li>角度：一个圆周均分360份，一份就是1度;弧度：如果圆弧的长度等于半径的长度，那么此时该圆弧所对应的角度就是1弧度</li>
              <li>一度等于多少弧度:var per = 2*Math.PI/360;</li>
              <li> ctx.arc(x,y,r,开始弧度,结束弧度,true(默认false表示顺时针；true表示逆时针));</li>
              <li>圆弧绘制:artTo方法需要三个点：需要一个起点，参数中需要两个点，这三个点形成两条切线，然后结合半径就能决定圆弧的位置</li>
              <li>ctx.moveTo(150, 20);ctx.arcTo(150,100,50,20,50);ctx.stroke();</li>
            </ul>
           <h4>绘制文本</h4>
           <ul>
             <li>ctx.font = '12px 微软雅黑' 设置字体</li>
             <li>描边字体 strokeText()</li>
             <li>填充字体 fillText(text,x,y,maxWidth)
                <ul>
                  <li>text 要绘制的文本</li>
                  <li>x,y 文本绘制的坐标（文本左下角）</li>
                  <li>maxWidth 设置文本最大宽度，可选参数</li>
                </ul>
             </li>
             <li>ctx.textAlign文本水平对齐方式，相对绘制坐标来说的；
              <ul>
                <li>left；center；right；start 默认；end；</li>
                <li>direction属性css(rtl ltr) start和end于此相关;如果是ltr,start和left表现一致;如果是rtl,start和right表现一致</li>
              </ul>
             </li>
             <li>ctx.textBaseline 设置基线（垂直对齐方式 ）
                <ul>
                  <li>top 文本的基线处于文本的正上方，并且有一段距离</li>
                  <li>middle 文本的基线处于文本的正中间</li>
                  <li>bottom 文本的基线处于文本的证下发，并且有一段距离</li>
                  <li>hanging 文本的基线处于文本的正上方，并且和文本粘合</li>
                  <li>alphabetic 默认值，基线处于文本的下方，并且穿过文字</li>
                  <li>ideographic 和bottom相似，但是不一样</li>
                </ul>
             </li>
             <li>measureText() 获取文本宽度obj.width</li>
           
           </ul>
           <h4> 实例</h4>
           <ul>
             <li>绘制渐变彩虹</li>
             <li>绘制饼图</li>
           
           </ul>
  </div>
  <div>
       <h2>canvas基础动画(6.23)</h2>
       <h4>drawImage</h4>
       <ul>
         <li>三个参数drawImage(img,x,y)
           <ul>
             <li>img 图片对象、canvas对象、video对象</li>
             <li> x,y 图片绘制的左上角</li>
           </ul>
         </li>
         <li>
             五个参数drawImage(img,x,y,w,h)
             <ul>
               <li> img 图片对象、canvas对象、video对象</li>
               <li> x,y 图片绘制的左上角</li>
               <li>w,h 图片绘制尺寸设置(图片缩放，不是截取)</li>
             </ul>
         </li>
         <li>
             九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1)
             <ul>
               <li>img 图片对象、canvas对象、video对象</li>
               <li></li>
               <li>x,y,w,h 图片中的一个矩形区域; x1,y1,w1,h1 画布中的一个矩形区域</li>
             </ul>
         </li>
       </ul>
       <h5>绘制多张图片时load加载问题：可以设置一个标识，每次加载完成一张图片，标识加一，当标识数量等于图片数量时，执行回掉函数</h5>
       <h5>创建的javascript标签在添加到页面才会加载，创建的img标签给它路径后就会加载</h5>
       <h4>定时函数</h4>
       <ul>
         <li>根据浏览器自适应进行帧绘制，有兼容性问题（部分浏览器默认大约1秒60下）function action(){requestAnimationFrame(action);}</li>
         <li> 事件队列中的任务何时执行？1、满足特定的条件2、主线程必须是空闲的</li>
         <li>js的运行时单线程的，浏览器是多线程的</li>
         <li> 函数的嵌套形成闭包；闭包包括内层函数和内存函数所处的环境（外层函数的作用域）</li>
         <li> 闭包可以延长变量的生命周期; 闭包可以缓存一些中间状态值</li>
       </ul>
       <h4>坐标变换（改变的是坐标的原点）</h4>
       <ul>
         <li>坐标系原点移动： ctx.translate(x,y);</li>
         <li>坐标系放大缩小 ctx.scale(x,y);参数表示宽高的缩放比例</li>
         <li>坐标系旋转 ctx.rotate(-Math.PI/4);参数表示旋转弧度</li>
         <li>在坐标系改变后，要清除画布的内容，可以用状态保存(save)，和状态恢复(restore)，就是坐标系修改前保存，修改后复原状态</li>
       
       </ul>
       <h4>实例</h4>
       <ul>
         <li>绘制精灵图逐帧动画</li>
         <li>通过键盘控制精灵图移动</li>
       </ul>
  </div>
  <div>
       <h2>像素鸟(6.25)</h2>
       <h5>判断一个坐标是否处于路径上：ctx.isPointInStroke(x,y)</h5>

       <ul>
         <li>对象的本质就是：无序的键值对集合</li>
         <li>所有的函数都是Function的实例对象</li>
         <li>所有的实例对象中都有一个__proto__属性，但是__proto__属性在实际开发中不可以使用，该属性是浏览器内部使用的，并且该属性并不是标准属性，该属性本质上就是创建该实例的构造函数的原型对象（prototype本质上就是一个对象---可以理解为Object的实例对象 {} new Object()）</li>
       
       </ul>
       
  </div>
</body>
</html>