<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  line-height: 1.5;
  color: #24292e;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-smi,
.markdown-body .pl-s .pl-s1 {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-s,
.markdown-body .pl-pds,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sre,
.markdown-body .pl-sr .pl-sra {
  color: #032f62;
}

.markdown-body .pl-v,
.markdown-body .pl-smw {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  color: #fafbfc;
  background-color: #b31d28;
}

.markdown-body .pl-c2 {
  color: #fafbfc;
  background-color: #d73a49;
}

.markdown-body .pl-c2::before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  font-weight: bold;
  color: #22863a;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  font-weight: bold;
  color: #005cc5;
}

.markdown-body .pl-mi {
  font-style: italic;
  color: #24292e;
}

.markdown-body .pl-mb {
  font-weight: bold;
  color: #24292e;
}

.markdown-body .pl-md {
  color: #b31d28;
  background-color: #ffeef0;
}

.markdown-body .pl-mi1 {
  color: #22863a;
  background-color: #f0fff4;
}

.markdown-body .pl-mc {
  color: #e36209;
  background-color: #ffebda;
}

.markdown-body .pl-mi2 {
  color: #f6f8fa;
  background-color: #005cc5;
}

.markdown-body .pl-mdr {
  font-weight: bold;
  color: #6f42c1;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  text-decoration: underline;
  color: #032f62;
}

.markdown-body .octicon {
  display: inline-block;
  vertical-align: text-top;
  fill: currentColor;
}

.markdown-body a {
  background-color: transparent;
  -webkit-text-decoration-skip: objects;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
}

.markdown-body strong {
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body svg:not(:root) {
  overflow: hidden;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
}

.markdown-body hr::before {
  display: table;
  content: "";
}

.markdown-body hr::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body table {
  border-spacing: 0;
  border-collapse: collapse;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body h1 {
  font-size: 32px;
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
  font-weight: 600;
}

.markdown-body h3 {
  font-size: 20px;
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
  font-weight: 600;
}

.markdown-body h5 {
  font-size: 14px;
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
  font-weight: 600;
}

.markdown-body p {
  margin-top: 0;
  margin-bottom: 10px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .octicon {
  vertical-align: text-bottom;
}

.markdown-body .pl-0 {
  padding-left: 0 !important;
}

.markdown-body .pl-1 {
  padding-left: 4px !important;
}

.markdown-body .pl-2 {
  padding-left: 8px !important;
}

.markdown-body .pl-3 {
  padding-left: 16px !important;
}

.markdown-body .pl-4 {
  padding-left: 24px !important;
}

.markdown-body .pl-5 {
  padding-left: 32px !important;
}

.markdown-body .pl-6 {
  padding-left: 40px !important;
}

.markdown-body::before {
  display: table;
  content: "";
}

.markdown-body::after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  float: left;
  padding-right: 4px;
  margin-left: -20px;
  line-height: 1;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 0.25em;
  padding: 0;
  margin: 24px 0;
  background-color: #e1e4e8;
  border: 0;
}

.markdown-body blockquote {
  padding: 0 1em;
  color: #6a737d;
  border-left: 0.25em solid #dfe2e5;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 24px;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2em;
  border-bottom: 1px solid #eaecef;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: 0.875em;
}

.markdown-body h6 {
  font-size: 0.85em;
  color: #6a737d;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: 0.25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #dfe2e5;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
}

.markdown-body code::before,
.markdown-body code::after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f6f8fa;
  border-radius: 3px;
}

.markdown-body pre code {
  display: inline;
  max-width: auto;
  padding: 0;
  margin: 0;
  overflow: visible;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code::before,
.markdown-body pre code::after {
  content: normal;
}

.markdown-body .full-commit .btn-outline:not(:disabled):hover {
  color: #005cc5;
  border-color: #005cc5;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #444d56;
  vertical-align: middle;
  background-color: #fafbfc;
  border: solid 1px #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
}

.markdown-body :checked+.radio-label {
  position: relative;
  z-index: 1;
  border-color: #0366d6;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.2em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}
 </style>
</head>
<body>
    <section class="markdown-body"><h2 id="loading-and-execution-">Loading and Execution 加载和运行</h2>
<h3 id="grouping-scripts-">Grouping Scripts 成组脚本</h3>
<ul>
<li>由于每个script标签下载时阻塞页面解析过程，所以限制页面script总数也可以改善性能。这个规则对内联脚本和外部脚本同样适用。每当页面解析碰到一个script标签时，紧接着有一段事件用于代码执行。最小化这些延时事件可以改善页面整体性能。</li>
<li>每个HTTP请求都会产生额外的性能负担，下载一个100kb的文件比下载四个25kb的文件要快。</li>
<li>考虑后台实现联合句柄的方式，javascript脚本src带多个参数为js文件名，后台返回一个多文件合成的打包文件。</li>
</ul>
<h3 id="-">动态创建脚本</h3>
<ul>
<li><p>动态创建脚本的重点在于，无论何处启动下载，文件的下载和运行都不会阻塞页面其它的处理过程。</p>
<ul>
<li>当文件使用动态脚本节点下载时，返回的代码通常立即执行（除了FIrefox和Opera，他们将等待此前所有的动态脚本节点执行完毕），当脚本不依赖其它脚本则没有问题，但如果依赖其它脚本则可以出现问题。</li>
<li>Firefox,Opera,Chorem和Safari都会在script节点接收完成之后发出一个load事件。</li>
<li>Internet Explorer支持另一种实现，它发出一个readystatechange事件，script元素有一个readyState属性，它的值随着下载外部文件的过程而改变。readyState有五种取值：uninitialized-默认状态，loading-下载完成，interactive-下载完成但尚不可用,complate-所有数据已经准备好。</li>
<li>但ie有时出现loading，有时只出现complate，最可靠的办法时这两种状态都进行检查。</li>
<li>如果是多重依赖，可用使用嵌套调用。多个文件次序十分重要，可用把多个文件打包成一个，因为是异步的，使用一个大文件并没有什么损失。</li>
<li><p>支持跨域</p>
<pre><code class="lang-js">function loadScript(url, callBack) {
     var script = document.createElement(&quot;script&quot;);
     script.type = &quot;text/javascript&quot;;
     if (script.readyState) { //IE
         script.onreadystatechange = function () {
             if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;) {
                 //    释放监听script脚本加载状态改变的事件,保证事件不会被触发两次。
                 script.onreadystatechange = null;
                 callBack();
             }
         }
     } else {
         script.onload = function () {
             callBack();
         }
     }
     script.src=url;
     document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);
 }
</code></pre>
<h3 id="xhr-">XHR脚本注入</h3>
</li>
<li><p>另一个非阻塞的方式获得脚本的方法是使用XMLHttpRequest(XHR)对象将脚本注入到页面中。</p>
</li>
<li>这种方法的主要优点是，你可用下载不立即执行的JavaScript代码。由于代码返回在script标签之外（换句话说不受script标签约束）,它下载后不会自动执行，这使得你可用推迟执行，直到一切都准备好了，另一个优点是，同样的代码在所有现代浏览器中都不会引发异常。</li>
<li>此方法最主要的限制是：javascript文件必须与页面放置在同一个域内。因为这个原因，大型网页通常不采用xhr脚本注入技术。</li>
</ul>
</li>
</ul>
<h2 id="data-access-">Data Access 数据访问</h2>
<h3 id="-">四种基本的数据存储位置</h3>
<ul>
<li>Literal values-直接量： 直接量仅仅代表直接，而不存储于特定位置。javascript的直接量包括：字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊含义的空值，以及未定义。</li>
<li>Variables 变量：开发人员使用var关键字创建用于存储数据值。</li>
<li>Array items-数组项：具有数字索引，存储一个javascript数组对象。</li>
<li>Object members-对象：具有字符串索引，存储一个javascript对象。</li>
</ul>
<h3 id="-">标识符识别性能</h3>
<ul>
<li>总的趋势是，对所有浏览器来说，一个标识符所在的位置越深，读写它的速度越慢。采用优化的JavaScript引擎的浏览器，如Safari4，访问域外标识符时没有这种性能损失。</li>
<li>尽可能的使用局部变量：用局部变量存储本地范围之外的变量值，如果题目在函数中的使用多于一次。如document对象。</li>
<li>无论是with表达式还是try-catch表达式的catch子句，以及函数中包含()的函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，无法通过静态解析。<ul>
<li>优化的Javascript引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统的作用域查找，取代以标识符方式进行快速查找。但涉及到一个动态作用域后，这个优化就不起作用了，引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域搜索。<ul>
<li>Closures,Scope,and Memory 闭包，作用域，和内存</li>
</ul>
</li>
<li>一个函数的激活对象于运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中闭包与非闭包相比，需要更多内存开销。<ul>
<li>缓存对象成员的值，在处理嵌套对象成员时特别重要。  </li>
<li>总结：</li>
<li>局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域总位置越深，访问所需时长越长。全局变量总数最慢的，因为它们总数位于作用域链的最后一环。</li>
<li>嵌套对象成员会造成重大性能影响，尽量少用。</li>
<li>一个属性或方法在原型中的位置越深，访问它的速度越慢。</li>
<li>可用将经常使用的对象才成员，数组项和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="dom-scripting-dom-">DOM Scripting DOM 编程</h2>
<ul>
<li>使用innerHTML和DOM方法创建一个1000行的表，在ie6中，innerHTML比对手快3倍，但在最新的基于WebKit的浏览器中慢于对手。</li>
<li><p>只表示元素节点的DOM属性（html标签）和表示所有节点的属性。</p>
<pre><code class="lang-js">Property                 Use as a replacementfor
children                 childNodes
childElementCount        childNodes.length
firstElementChild        firstChild
lastElementChild         lastChild
nextElementSibing        nextSibling
previousElementSibling   previousSibling     

//IE7,8,9只支持children，其它不支持？？其它浏览器都支持
</code></pre>
<ul>
<li>querySelectorAll返回一个NodeList--由符合条件构成的类数组对象。这个选择器API在IE8开始兼容，当需要联合查询时，性能比getElementsByTagName快了2-6倍。</li>
<li>getElementsByTagName返回的时一个HTML集合。</li>
</ul>
</li>
</ul>
<h3 id="-">重排和重绘</h3>
<ul>
<li>一颗DOM树，表示页面结构，一颗渲染树，表示节点如何展示。  </li>
<li>获取布局信息的操作将导致刷新队列动作，意味着使用了以下方法<ul>
<li>布局信息由这些属性和方法返回最新的数据，所以浏览器不得不运行渲染队列中待改变的项目并重新排版以返回正确的值。</li>
<li>在改变风格过程中，最好不要使用这些查询API。任何一个访问都将刷新渲染队列。即使你正在获取那些最近未发生改变的或者与最新改变无关的布局信息。<pre><code class="lang-js">offsetTop序列  scrollTop序列  clienTop序列  getComputedStyle()(currentStyle in IE);
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="-">最小化重绘和重排版</h3>
<ul>
<li>改变风格：3次改变元素的风格，在老版浏览器中重绘（重排）了3次，大多数现代浏览器优化了只进行一次重排。<ul>
<li>更高效的方法是使用cssText，合并在一起执行，只修改一次DOM。</li>
<li>另一个一次性修改风格的办法是修改css的类名称。</li>
</ul>
</li>
</ul>
<h3 id="-dom">批量修改DOM</h3>
<ul>
<li>当需要对DOM元素进行多次修改时，可以通过以下步骤减少重排和重绘的次数。<ul>
<li>1.从文档流中摘除元素。</li>
<li>2.对其进行多次改变。</li>
<li>3.将元素带回文档中</li>
<li>有三种方法可以把元素从文档中摘除<ul>
<li>隐藏元素，进行修改，然后显示它。</li>
<li>使用一个文档片段在已存DOM之外创建一个子树，然后将它拷贝到文档中(document.createDocumentFragment)。</li>
<li>将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。</li>
<li>推荐尽可能的使用文档片段（第二张解决方案），因为它涉及到最少数量的DOM操作和重排版。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-">缓冲布局信息</h3>
<ul>
<li>浏览器通过队列化修改和批量运行的方法，尽量减少重排次数。当查询布局信息如偏移量，滚动条位置，或风格属性时，浏览器刷新队列并执行所有修改操作，以返回最新的数值。最好是减少对布局信息的查询次数，查询时将它赋值给局部变量，并用局部变量来计算。</li>
</ul>
<h3 id="-">将元素提出动画流</h3>
<ul>
<li>使用以下步骤可以避免大部分页面进行重排版<ul>
<li>1.使用绝对坐标定位页面动画的元素，使它位于页面布局流之外。</li>
<li>2.启动元素动画。当它扩大时，它临时覆盖部分页面。这是一个重绘过程，但只影响页面的一小部分，避免重新排版并重绘一大块页面。</li>
<li>3.动画结束时，重新定位，从而只一次下移文档其它元素的位置。</li>
</ul>
</li>
</ul>
<h4 id="ie-hover">IE和:hover</h4>
<ul>
<li>如果大量元素使用了:hover会降低反应速度。 </li>
</ul>
<h3 id="-">总结</h3>
<ul>
<li>DOM访问和操作时现代网页应用中很重要的一部分，但每次通过桥梁从ECMAScript岛到达DOM岛时，都会被收取“过桥费”。为减少DOM编程中性能的损失，请牢记以下几点：<ul>
<li>最小化DOM访问，在javaScript端做尽可能多的事情。</li>
<li>在反复访问的地方使用局部变量存放DOM引用。</li>
<li>小心地处理HTML集合，因为他们表现出“存在性”，总是对底层文档重新查询。将集合的length属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以把集合拷贝到数组中。</li>
<li>可能的话，使用速度更快的API，诸如querySelectorAll和firstElementChild。</li>
<li>注意重绘和重排版；批量修改风格，离线操作DOM树，缓存并减少对布局信息的访问。</li>
<li>动画中使用绝对坐标，使用拖放代理。</li>
<li>使用事件托管技术最小化事件句柄数量。</li>
</ul>
</li>
</ul>
<h2 id="-">算法和流程控制总结</h2>
<ul>
<li>for,while,do-while循环的性能特性相似，谁也不比谁更快或更慢。</li>
<li>除非要迭代遍历一个属性未知的对象，否则不要使用for-in循环。</li>
<li>改善循环性能的最好办法是减少每次迭代中的运算量，并减少循环迭代次数。<ul>
<li>如先取集合的长度记录下来。</li>
<li>对循环进行倒序，(for var i=10;i--){}判断i是否为true。<ul>
<li>一般来说，switch总数比if-else更快，但并不总是最好的解决方法。</li>
<li>当判断条件较多时，查表法（数组查询）比if-else或者switch更快。</li>
<li>浏览器的调用栈尺寸限制了递归算法在javascript中的应用；栈溢出错误导致其它代码也不能正常执行。</li>
<li>如果遇到一个栈溢出错误，将方法修改为一个迭代算法或者使用制表法（把计算结果缓存到一个数组中，下次遇到同样的计算直接返回）可以避免重复工作。</li>
<li>运行的代码总量越大，使用这些策略带来的性能提示就越明显。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-">字符串和正则表达式</h2>
<ul>
<li>加和加等于操作<ul>
<li>发生了四个步骤： str+=&quot;one&quot;+&quot;two&quot;;<ul>
<li>1.内存中创建了一个临时字符串</li>
<li>2.临时字符串的值被赋予“onetwo”</li>
<li>3.临时字符串与str的值进行连接</li>
<li>4.结果赋予str</li>
<li>str+=“one”;str+=&quot;two&quot;;可以通过两个离散表达式直接将内容附加在str上避免了临时字符串。在大多数浏览器上这样做可加快10%-40%;</li>
<li>str=str+&quot;one&quot;+&quot;two&quot;;这就避免了使用临时字符串，因为赋值表达式开头以str为基础，一次追加一个字符，从左往右依次连接。如果改变连接顺序，就会失去这种优化。这与浏览器合并字符串时分配内存的方法有关。除IE以外，浏览器尝试扩展表达式左侧字符串的内存，然后简单的将第二个字符串拷贝到它的尾部。如果在一个循环中，基本字符串位于最左端，就可以避免多次复制一个越来越大的基本字符串。</li>
<li>这些技术并不适用与IE。它们几乎没有任何作用，在IE8上甚至比IE7和早期版本更慢。这与IE执行的连接操作的机制有关。在IE8中，连接字符串只是记录下构成新字符串的各部分字符串的引用。在最后时刻（当你真正使用连接后的字符串时），各部分字符串才被逐个拷贝到一个新的“真正的”字符串中，然后用它取代先前的字符串引用，所以并非每次使用字符串时都发生合并操作。</li>
</ul>
</li>
</ul>
</li>
<li>数组连接（join）<ul>
<li>在大多数浏览器上，数组连接比连接字符串的其它方法更慢，但在事实上，为一种补偿方法，在IE7或者更早的浏览器上它是连接大量字符串唯一高效的途径。</li>
</ul>
</li>
<li>concat<ul>
<li>追加一个或多个字符串，大多数情况下比简单的+和+=慢一些， 看起来和数组连接差不多，但通常它更慢（Opera除外），而且它还潜伏着灾难性的性能委托，正如IE7和更早版本中使用+和+=创建大字符串一样。</li>
</ul>
</li>
</ul>
<h3 id="-">正则表达式优化</h3>
<ul>
<li>分支：当一个正则表达式扫描目标字符串时，它从左往右逐个扫描正则表达式的组成部分，在每个位置上测试能不能找到一个匹配。对于每一个量词和分支，都必须决定如何继续进行。如果是一个量词（诸如*,+?,或者{2,}）,正则表达式都必须决定何时匹配更多的字符；如果遇到分支(|),它必须从这些选项中选择一个进行尝试。</li>
<li>回溯：每当正则表达式做出这样的决定，如果有必要的话，它会记住另一个选项，以备将来返回后使用。如果所选的方案匹配成功，正则表达式将继续扫描正则表达式模板，如果其全部匹配也成功了，那么匹配就结束了。但是如果选择的方案未能发现相应匹配，或者后来的 匹配也失败了，正则表达式将回溯到最后一个决策点，然后在剩下的选项中选一个。它继续这样下去，直到找到一个匹配，或者量词和分支选项的所有可能的排列组合都尝试失败了，那么它将放弃这一过程，然后移动到此过程开始位置的下一个字符上，重复此过程。</li>
<li><em>贪婪匹配和</em>？惰性（又名非贪婪）量词</li>
<li>回溯失控（无意义的回溯）的解决方案：<ul>
<li>具体化：用更具体的替代过于宽泛的。</li>
<li>使用前瞻和向后引用列举原子组:(?=(pattern to make atomic))\1<ul>
<li>在任何打算使用原子组的模式中这个结构都是可重用的。只要记住，你需要适当的后向引用次数，如果你的正则表达式包含多个捕获组。</li>
<li>正则表达式每次找到一个中间标签就退出一个前瞻，它在前瞻过程中丢弃所有回溯位置，下一个后向引用简单地重新匹配前瞻过程中发现地字符，将他们作为实际匹配地一部分。</li>
</ul>
</li>
</ul>
</li>
<li>提高正则表达式效率的更多方法<ul>
<li>关注如何让匹配更快失败</li>
<li>正则表达式以简单的，必须的子元开始</li>
<li>尽量避免一个正则表达式做太多的工作。复杂的搜索问题需要条件逻辑，拆分为两个或多个正则表达式让容易解决，通常也更高效，每个正则表达式只在最后的匹配结果中执行查找。在一个模板中完成所有工作的正则表达式怪兽很难维护，而且容易引起回溯相关的问题。<ul>
<li>正则表达式去字符串手尾空格。<pre><code class="lang-js">if(!String.prototype.trim){
String.prototype.trim=function(){
return this.replace(/^\s+/,&quot;&quot;).replace(/\s+$/,&quot;&quot;);
}
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-">响应接口</h2>
<ul>
<li>总的来说，大多数浏览器有一个单独的处理进程，它由两个任务所共享：JavaScript任务和用户界面更新任务。每个时刻只有其中一个的操作得以执行，也就是说当JavaScript代码运行时用户界面不能对输入产生反应，反之亦然。或者说，当JavaScript运行时，用户界面就被“锁定”了。管理号JavaScript运行时间对网页应用的性能很重要。</li>
<li>JavaScript和UI更新共享的进程通常被称作浏览器UI线程（虽然对所有浏览器来说“线程”一词不一定准确）。此UI线程围绕这一个简单的队列系统工作。任务被保存在队列中直至进程空闲。一旦空闲，队列中的下一个任务将被检索和运行。这些任务不是运行JavaScript代码，就是执行UI更新，包括重绘和重排。此进程中最令人感兴趣的部分是每次输入均导致一个或多个任务被加入队列。</li>
<li>当所有的UI线程任务执行之后，线程进入空闲状态，并等待更多任务被添加到队列中。空闲状态是理想的，因为所有的用户操作都会立即引发一次UI更新。如果用户企图在任务运行时与页面交互，不仅没有及时的UI更新，而且不会有新的UI更新任务被创建和加入队列。实际上，大多数浏览器在JavaScript运行时停止UI线程队列中的任务，也就是说JavaScript任务必须尽快结束，以免对用户体验照成不良体验。</li>
<li>浏览器限制<ul>
<li>浏览器在JavaScript运行时间上采取了限制。此类限制有两个：调用栈尺寸限制和长时间脚本限制。</li>
</ul>
</li>
<li><p>分解任务</p>
<ul>
<li>因为浏览器定时器精度问题，最好设置延时时间大于25毫秒</li>
<li>通常将一个任务分解成一系列子任务。如果一个函数运行时间太长，那么查看它是否可以分解成一系列能够短时间完成的较小的函数。可以将一行代码简单的看作一个原子任务，多行代码组合在一起构成一个独立任务。某些函数可以基于函数调用进行拆分。</li>
<li><p>如果函数运行时间太长，它可以拆分成一系列更小的步骤，把独立方法放在定时器中调用。可以将每个函数放入一个数组。</p>
<pre><code class="lang-js">  function saveTask(arr) {
     var newArr = arr.concat();
     setTimeout(function () {

         var fn= newArr.shift();
         fn();
         if (newArr.length &gt; 0) {
            saveTask(newArr);

         }
     }, 25)
 }
</code></pre>
<ul>
<li>限时运行代码 </li>
<li>可以使用批处理代码。</li>
<li>JavaScript可连续运行的最大时间时100毫秒，最好是不要让任何JavaScript代码持续运行超过50毫秒。</li>
<li>推荐使用定时器序列，同一时间只有一个定时器存在，只有当这个定时器结束时才创建一个新的定时器。以这种方式使用定时器不会带来性能问题。</li>
<li>要在网页应用中限制高频率重复定时器的数量。建议创建一个独立的重复定时器，每次执行多个操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-">网页工人线程--必须在服务器环境下执行</h3>
<ul>
<li>自JavaScript诞生以来，还没有办法在浏览器UI线程之外运行代码。网页工人线程API改变了这种状况，它引入一个接口，使代码运行而不占用浏览器UI线程的时间。作为最初的HTML5的一部分，工人线程API已经分离出去成为独立的规范。<ul>
<li>网页工人线程对网页应用来说是一个潜在的巨大性能提升，因为新的工人线程在自己的线程中运行JavaScript。这意味着，工人线程中的代码运行不仅不会影响浏览器UI，而且也不会影响其他工人线程中运行的代码。</li>
</ul>
</li>
<li>工人线程运行的环境<ul>
<li>由于网页工人线程不绑定UI线程，这也意味着它们将不能访问许多浏览器资源。JavaScript和UI更新共享一个进程的部分原因是它们之间互访频繁，如果这些任务失控将导致糟糕的用户体验。网页工人线程修改DOM将导致用户界面出错，但每个网页工人线程都有自己的全局运行环境，只有JavaScript特性的一个子集可用。工人线程的运行环境由下列部分组成：<ul>
<li>一个浏览器对象，只包含四个属性：appName,appVersion,userAgent和platform    </li>
<li>一个self对象指向全局工人线程对象</li>
<li>一个importScripts()方法，使工人线程可以加载外部JavaScript文件。</li>
<li>所有的ECMASript对象，诸如OBject，Array，Data，等等</li>
<li>XMLHttpRequest 构造器</li>
<li>setTimeout和setInterval方法</li>
<li>close方法可立即停止工人线程</li>
</ul>
</li>
<li>因为网页工人线程有不同的全局运行环境，不能在JaavaScript代码中创建。事实上，需要创建一个完全独立的JavaScript文件，包含那些在工人线程中运行的代码。要创建网页工人线程，必须传入这个JavaScript文件的URL：<ul>
<li>var worker=new Worker(&quot;code.js&quot;)</li>
<li>此代码一旦执行，将为指定文件创建一个新线程和一个新的工人线程运行环境。此文件被异步下载，直到下载并运行完之后才启动工人线程。<ul>
<li>工人线程交互</li>
<li>工人线程和网页代码通过事件接口进行交互。网页代码可通过postMessage()方法向工人线程传递数据，它接受单个参数，即传递给工人线程的数据。此外，在工人线程中还有onmessage事件句柄用于接受信息。<pre><code class="lang-js">var worker=new Worker(&quot;code.js&quot;);
worker.onmessage=function(event){
alert(event.data);
}
worker.postMessage(&quot;Nicholas&quot;);
</code></pre>
</li>
<li>工人线程从message事件中接收数据。这里定义了一个onmessage事件句柄，事件对象具有一个data属性存放传入的数据。工人线程可通过它自己的postMessage()方法将信息返回给页面<pre><code class="lang-js">// inside code.js
self.onmessage=function(event){
self.postMessage(&quot;Hello,&quot; + event.data+&quot;!&quot;)
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最终的字符串结束于工人线程的onmessage事件句柄。消息系统是页面和工人线程之间唯一的交互途径。  <ul>
<li>只有某些类型的数据可以使用postMessage()传递。可以传递原始值（string,number,boolean,null,和undefined）,也可以传递Object和Array的实例，其他类型就不允许了。有效数据被序列化，传入或传出工人线程，然后反序列化。即使看上去对象直接穿了过去，实例其实是同一个数据完全独立的表述。视图传递一个不支持的数据类型将导致JavaScript报错。</li>
<li>加载外部文件</li>
<li>当工人线程通过importScript()方法加载外部的JavaScript文件，它接收一个或多个URL参数，指出要加载的JavaScript文件网址。工人线程以阻塞方式调用importScript()，直到所有文件加载完成并执行之后，脚本才继续执行。由于工人线程在UI线程之外运行，这种阻塞不会影响UI响应。例如：<pre><code class="lang-js">//inside code.js
importScripts(&quot;file1.js&quot;,&quot;file2.js&quot;);
self.onmessage=function(event){
  self.postMessage(&quot;Hello, &quot;+event.data+&quot;!&quot;)
}
//此代码第一行包含两个JavaScript文件，它们将在工人线程中使用
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="-">实际用途</h4>
<ul>
<li>网页工人线程适合于那些纯数据的，或者于浏览器无关的长运行脚本。它看起来用处不大，而网页应用程序中通常有一些数据处理功能受益于工人线程，而不是定时器。</li>
<li>考虑这样一个例子，解析一个很大的JSON字符串。假设数据足够大，至少需要500毫秒才能完成解析任务。很显然时间太长了以至于不能允许JavaScript在客户端运行它，因为它会干扰用户体验。此任务难以分解成用于定时器的小段任务，所以工人线程成为理想的解决方案。下面的代码说明了它在网页上的应用。</li>
</ul>
<pre><code class="lang-js">   var worker=new worker(&quot;jsonparser.js&quot;)
   worker.onmessage=function(event){
       var jsonData=event.data;
       evaluateData(jsonData);
   }
   worker.psotMessage(jsonText);


   //inside of jsonparser.js

   self.onmessage=function(event){

       var jsonText=event.data;

       var jsonData=JSON.parse(jsonText);

       self.postMessage(jsonData);
   }
</code></pre>
<ul>
<li>请注意，即使JSON.parse()可能需要500毫秒或更多时间，也没有必要添加跟多代码来分解处理过程。此处理过程发生在一个独立的线程中，所以可以让它一直运行解析过程而不会干扰用户体验。</li>
<li>页面使用postMessage()将一个JSON字符串传给工人线程。工人线程在它的onmessage时间句柄中收到这个字符串也就是event.data，然后开始解析它。完成时所产生的JSON对象通过工人线程的postMessage()方法传回页面。然后此对象便成为页面onmessge事件句柄的event.data。请记住，此工程只能在FIrefox3.5和更高版本中运行，而Safari4和Chrome3中，页面和工人线程之间只允许传递字符串。<ul>
<li>解析一个大字符串只是许多受益于网页工人线程的任务之一。其它可能受益的任务如下：<ul>
<li>编/解码一个大字符串</li>
<li>复杂数学运算（包括图像和视频处理）</li>
<li>给一个大数组排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="-">总结</h3>
<ul>
<li>JavaScript和用户界面更新在同一个进行内运行，同一时刻只有其中一个可以运行。着意味着当JavaScript代码正在运行时，用户界面不能响应输入，反之亦然。有效的管理UI线程就是要确保JavaScript不能运行太长时间，以免影响用户体验。最后，请牢记如下几点：<ul>
<li>Javascript运行时间不应该超过100毫秒。过长的运行时间导致UI更新出现可察觉的延迟，从而对整个用户体验产生负面影响。</li>
<li>JavaScript运行期间，浏览器响应用户交互行为存在差异。无论如何，JavaScript长时间运行将导致用户体验混乱和脱节。</li>
<li>定时器可用于安排代码推迟执行，它使得你可以将长运行脚本分解成为一系列较小的任务。</li>
<li>网页工人线程是新式浏览器才支持的特性，它运行你在UI线程之外运行JavaScript代码而避免锁定UI。</li>
<li>网页应用程序越复杂，积极主动的管理UI线程就越显的重要。没有什么JavaScript代码可以重要到允许影响用户体验的程度。</li>
</ul>
</li>
</ul>
<h2 id="ajax-javascript-xml">Ajax异步JavaScript和XML</h2>
<h3 id="-">请求数据</h3>
<ul>
<li>有五种常用技术用于向服务器请求数据<ul>
<li>XMLHttpRequest(XHR)</li>
<li>Dynamic script tab insertion 动态脚本标签插入</li>
<li>iframes</li>
<li>Comet</li>
<li>Multipart XHR 多部分XHR</li>
<li>在现代高性能JavaScript中使用的三种技术是XHR，动态脚本标签插入和多部分XHR使用Comet和iframe(作为数据传输技术)往往是极限情况。</li>
</ul>
</li>
<li>XMLHttpRequest<ul>
<li>readyState对于4表示整个响应报文已经接收完成可用于操作。</li>
<li>readyState等于3则表示此时正在与服务器交互，响应报文还在传输之中。着就是所谓的“流”，它是提高数据请求性能的强大工具。<pre><code class="lang-js">var xhr=new XHRHttpRequest();
xhr.onreadystatechange=function(){
   if(xhr.readystate===3){
       var data=xhr.responseText;
   }
   if(xhr.readystate===4){
        var responseHander=xhr.getAllResponseHeaders();
        var data=xhr.responseText;
   }
}
xhr.open(&#39;get&#39;,url);
xhr.setRequestHander(&quot;X-Requested-With&quot;,&quot;XMLHttpRequest&quot;);
xhr.send();
</code></pre>
</li>
</ul>
</li>
<li>动态脚本标签插入<ul>
<li>该技术克服了XHR的最大限制：它可以从不同域的服务器上获取数据。这是一种黑客技术，而不是实例化一个专用对象，你用JavaScript创建了一个新脚本标签，并将它的源属性设置为一个指向不同域的URL。</li>
<li>但是动态脚本标签插入与XHR相比只提供更少的控制。不能通过请求发送信息头。参数只能通过GET方法传递，不能用POST。你不能设置请求超时或重试，实际上，你不需要知道它是否失败了。你必须等待所有数据返回之后才可以访问它们。不能访问响应信息头或者像访问字符串那样访问整个响应报文。</li>
<li>最后一点非常重要。因为响应报文被用作脚本标签的源码，它必须是可以执行的JavaScript。你不能使用裸XML，或者裸JSON，任何数据，无论什么格式，必须在一个回调函数之中被组装起来。</li>
<li>尽管有这些限制，此技术仍然非常迅速。其响应结果是运行JavaScript，，而不是作为字符串必须被进一步处理。正因为如此，它可以是客户端上获取并解析数据最快的方法。</li>
<li>请小心使用这种技术从你不能直接控制的服务器请求数据。JavaScript没有权限和访问控制的概念，所以在你的页面上使用动态脚本标签插入的代码都可以完全控制整个页面。包括修改任何内容，将用户重定向到另一个站点，或跟踪他们在页面上的操作并将数据发送给第三方。使用外部来源的代码时务必非常小心。</li>
</ul>
</li>
<li>多部分XHR   <ul>
<li>这里介绍最新的技术，多部分XHR(MXHR)允许你只用一个HTTP请求就可以从服务端获取多个资源。它通过将资源（可以是css文件，HTML片段，JavaScript代码，或base64编码的图片）打包成一个由特定分隔符界定的大字符串，从服务器发送到客户端。JavaScript代码处理此长字符串，根据它的媒体类型和其它“信息头”解析每个资源</li>
<li>这段PHP代码读取三个图片，并将它们转化成base64字符串。它们之间用一个简单的字符，UNICODE的1，链接起来，然后返回给客户端。</li>
<li>图像不是从base64转化成二进制，而是使用data:URL并指定image/jpeg媒体类型。</li>
</ul>
</li>
</ul>
<pre><code class="lang-js">   var req=new XMLHttpRequest();
        req.open(&#39;GET&#39;,&#39;mxhr.php&#39;);
        req.onreadystatechange=function(){
            if(req.readyState==4){
                splitImages(req.responseText);
            }
        }
        req.send(null);

        function splitImages(imageString){
            var imageData=imageString.split(&quot;\u0001&quot;);
            var imageElement;
            for(var i=0,len=imageData.length;i&lt;len;i++)
            {
                 imageElement=document.createElement(&quot;img&quot;);
                 imageElement.src=&#39;data:image/jpg;base64,&#39;+imageData[i];
                 document.getElementById(&#39;container&#39;).appendChild(imageElement);
            }
        }
</code></pre>
<pre><code class="lang-php"> &lt;?php
header(&#39;Content-type:text/html;charset=utf-8&#39;);
$images=array(&#39;2.png&#39;,&#39;3.png&#39;,&#39;1.png&#39;,&#39;3.png&#39;,&#39;2.png&#39;);
foreach($images as $image){
    $image_fh=fopen($image,&#39;r&#39;);
    $image_data=fread($image_fh,filesize($image));
    fclose($image_fh);
    $payloads[]=base64_encode($image_data);

}
  $newline=chr(1);
  echo implode($newline,$payloads);
?&gt;
</code></pre>
<ul>
<li><p>由于MXHR响应报文越来越大，有必要每个资源收到是立即处理，而不是等待整个报文接收完成。这可以通过监听readyState3实现。</p>
<pre><code class="lang-js">      var req=new XHRHttpRequest();
      var getLatestPacketInterval,lastLengh=0;
      req.open(&#39;GET&#39;,&#39;&#39;);
      req.onreadystatechange=readyStateHandler;
      function readyStateHandler(){
          if(req.readyState===3&amp;&amp;getLatestPacketInterval==null){
              getLatestPacketInterval=setInterval(function(){
                  getLatestPacket();
              },25)
          }
          if(req.readyState===4){
              clearInterval(getLatestPacketInterval);
              etLatestPacket();
          }
      }

      function getLatestPacket(){
          var length=req.responseText.length;
          var packet=req.reaponseText.substring(lastLengh,length);
          processPacket(packet);
          lastLengh=length;
      }
</code></pre>
</li>
<li>以健壮的方式使用MXHR，有下面这个库：<blockquote>
<p><a href="http://techfoolery.com/mxhr/">http://techfoolery.com/mxhr/</a></p>
<ul>
<li>使用此技术有一些缺点，其中最大的缺点是以此方法获得的资源不能被浏览器缓存。如果你使用MXHR获取一个特定的css文件然后在下一个页面中正常加载它，它不在缓存中。因为整批资源是作为一个长字符串传输的，然后由JavaScript代码分隔。由于没有办法用程序将文件放入浏览器中，所以用这种方法获取的资源也无法存放在那里。 </li>
<li>老版本IE6，7不正常readyState3或data:URL. </li>
<li>网站为每个页面使用了独一无二的打包的JavaScript或css文件以减少HTTP请求，因为它们对么个页面来说是唯一的，所以不需要从缓存中获取，除非重新载入特定页面。</li>
<li>由于HTTP请求是Ajax中最极端的瓶颈之一，减少其需求数量对整个页面性能有很大影响。尤其是当你将100个图片转化为一个MXHR请求时，Adhoc在现代浏览器上测试了大量图片，其结果显示出此技术比逐个请求快了4到10倍。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="-">发送数据</h3>
<ul>
<li>有时你不关心接收数据，而只要将数据发送给服务器。可以发送用户的非私有信息以备日后分析，或者捕获所有脚本错误然后将有关细节发送给服务器进行记录和提示。当数据只需发送给服务器时，有两种广泛应用的技术：XHR和灯标</li>
<li>HHRHttpRequest<ul>
<li>通过xhr对象的onerror事件可以在失败后重新提交数据。</li>
<li>使用XHR将数据发回服务器时，get更快。这个是因为对少量数据来说，向服务器发送一个get请求要占用一个独立的数据包。而一个POST至少发送两个数据包，一个用于信息头。另一个用于POST体。POST更适合域向服务器发送大量数据，即因为它不额外额外数据包的数量，而get在url会限制长度。<ul>
<li>灯标</li>
</ul>
</li>
<li>此技术与动态脚本插入非常类似。JavaScript用于创建一个新的Image对象，将src设置为服务器上一个脚本的URL。此URL包含我们打算通过GET格式传回的键值对数据。注意并没有创建img元素或者将它们插入DOM中。 </li>
<li>(new Image()).src=url+&#39;?&#39;+params;</li>
<li>服务器取得此数据并保存下来，而不必向客户端返回什么，因此没有实际的图像展示。这是将信息发回服务器的最有效方法。其开销很小，而且任何服务器端错误都不会影响客户端。</li>
<li>可以监听Image对象的load事件，可以判断服务器是否成功收到了数据，通过检测服务器返回图片的宽度和高度（如果返回了一张图片）并用宽度或高度判断服务器的状态。（宽度为1表示“成功”，2表示“重试”）</li>
<li>如果不需要为此响应数据，那么应当发送一个204 No Coutent响应代码，无消息正文。它将阻止客户端继续等待永远不会到来的消息体（后台设置）。</li>
<li>灯标是向服务器回送数据最快和最有效的方法。服务器根本不需要发回任何响应正文，所以不比担心客户端下载数据。唯一的缺点就是接收到的响应类型是受限的。如果需要向客户端返回大量数据，那么使用XHR。如果只关心将数据发送到服务器端（可能需要减少的回复），那么使用图像灯标。</li>
</ul>
</li>
</ul>
<h4 id="-">数据格式总结</h4>
<ul>
<li>总的来说越轻量级的格式越好，最好是JSON和字符分隔的自定义格式（
\u0001等字符进行分割）。如果数据集很大或者解析时间成问题，那么就使用这两种格式之一。   </li>
<li>JSON-P数据，用动态脚本标签插入法获取。它将数据视为可运行的JavaScript而不是字符串，解析速度极快。它能够跨域使用，但不应涉及敏感数据。</li>
<li>字符分割的自定义格式，使用XHR或动态脚本标签插入技术提取。使用split()解析。此技术在解析非常大数据集时比JSON-P技术略快，而且通常文件尺寸更小。</li>
</ul>
<h3 id="ajax-">Ajax性能导向</h3>
<ul>
<li>缓存数据<ul>
<li>最快的Ajaxqq就是你不要用到它。有两种主要方法避免发出一个不必要的请求：</li>
<li>在服务器端，设置HTTP头，确保返回报文将被缓存在浏览器中。
在客户端，于本地缓存已获取的数据，不要多次请求同一个数据。</li>
<li>第一种就是最容易设置和维护，而第二个给你最大程度的控制。</li>
</ul>
</li>
<li>设置HTTP头<ul>
<li>Expires头设置浏览器应当缓存响应报文的时间。</li>
<li>本地缓存数据<ul>
<li>除了依赖浏览器处理缓存之外，可以用手工方法实现它，直接存储那些从服务器收到的响应报文，将响应报文放在一个对象中，以URL为键值索引它。</li>
<li>如果用户可能触发某些动作导致一个或多个报文报废，直接delete删除对应属性，十分方便。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="-ajax-">了解Ajax库的限制</h4>
<ul>
<li>直接操作XHR对象减少了函数开销，进一步提高了性能，只是放弃使用Ajax库，可能会在古怪的浏览器上遇到一些问题。</li>
</ul>
<h4 id="-">总结</h4>
<ul>
<li>作为数据格式，纯文本和HTML是高度限制的，但它们可以节省客户端CPU周期。XML被广泛应用普遍支持，但它非常冗长且解析缓慢。 JSON是轻量级的，解析迅速（作为本地代码而不是字符串），交互性与XML相当。字符分割的自定义格式非常轻量，在大量数据集解析时速度最快，但需要编写额外的程序在服务器构造格式，并在客户端解析。</li>
<li>当从页面域请求数据时，XHR提供最完善的控制和灵活性，尽管它将所有传入数据视为一个字符串，这有可能降低解析速度。另一方面，动态脚本标签允许跨域请求和本地允许JavaScript，虽然它的接口不够安全，而且也不能读取信息头或响应报文。多部分XHR可减少请求的数量，可一次响应中处理不同文件类型  ，尽管它不能缓存收到的响应报文（是因为多个css文件打包在一起，其它页面有自己的css，复用性不高）。当发送数据时，图像灯标时最简单和最有效的方法。xhr也可用PSOT方法发送大量数据。 </li>
<li>减少请求数量，可通过JavaScript和css文件打包，或者使用MHXHR。</li>
<li>缩短网页的加载时间，在页面其它内容加载之后，使用Ajax获取少量重要文件。</li>
<li>确保代码错误不要直接显示给用户，并在服务器处理错误。</li>
<li>学会何时使用一个健壮的Ajax，何时编写自己的底层Ajax代码。</li>
</ul>
<h2 id="-">编程实践</h2>
<h4 id="-">避免二次评估</h4>
<ul>
<li>Javascript与许多脚本语言一样，允许你在程序中获取一个包含代码的字符串然后运行它。有四种标准方法可以实现：eval(),Function构造器,setTimeout(),setInterval()。每个函数都允许你传入一串字符串并运行它。</li>
<li>当你在JavaScript代码中执行（另一段）JavaScript代码时，你得付出二次评价得代价。此代码首先被评估正常代码，然后在执行过程中，运行字符串中得代码时发生另一次评估。二次评估是一项昂贵得操作，与直接包含相应代码相比占用更长时间。<ul>
<li>使用eval代替直接代码访问10000个数组项，在不同浏览器上得差异非常巨大。</li>
<li>访问数组项时间上巨大差异，是因为每次使用eval时要创建一个新得解释/编译实例。同样得过程也发生在Function(),setTimeout,setInterval上，自动使代码执行速度变慢。</li>
<li>避免二次评估使实现最优化得Javascript运行时性能得关键。</li>
</ul>
</li>
</ul>
<h4 id="-">使用对象/数组直接量</h4>
<ul>
<li>使用直接量赋值很快。作为一个额外的好处，直接量在代码中占用较少的空间，所以整个文件尺寸可以更小。</li>
<li>随着对象属性和数组项数的增加，使用直接量的好处也随之增加。直接量比创建一个对象在几乎所以的浏览器中都运行更快。</li>
</ul>
<h4 id="-">延时加载</h4>
<ul>
<li>本质上就是判断target.addEventListener是否存在，再把当前函数覆盖了。形成一个新函数，在最后调用一次。只要调用了一次，以后调用速度就快了。</li>
<li>调用一个延时加载函数总是在第一次使用较长时间。</li>
<li><p>延时加载适用于函数不会在页面上立即被用到的场合。</p>
<pre><code class="lang-js">function addHandler(target,eventType,handler){
 if(target.addEventListener){
     addHandler=function(target,eventType,handler){

     }
 }else{
       addHandler=function(target,eventType,handler){

     }
 }
 addHandler();
}
</code></pre>
</li>
</ul>
<h4 id="-">条件预加载</h4>
<ul>
<li>除延时加载之外还有另一种方法称为条件预加载，它在脚本加载之前进行检测，而不是等待函数调用。这样做检测仍只做一次，但在此过程中来的更早。</li>
<li>条件预加载确保所有函数调用时间相同。其代价是在脚本加载时进行测试。预加载适用于一个函数马上就会被用到，而且整个页面生命周期中经常使用的场合。<pre><code class="lang-js">var addHandler=document.body.addEventListener?function(){}:function(){}
</code></pre>
</li>
</ul>
<h4 id="-">位操作运算符</h4>
<ul>
<li><p>位掩码操作非常快，操作发生在系统底层，如果许多选项保存在一起并经常检查，位掩码有助于加快整体性能。</p>
<h4 id="-">原生方法</h4>
</li>
<li><p>无论你怎么优化JavaScript代码，它永远不会比JavaScript引擎提供的原生方法更快。其原因十分简单：JavaScript的原生部分在你写代码之前它们就已经存在于浏览器中了，都是用底层语言写的，诸如c++。这意味着这些方法被编译成机器码，作为浏览器的一部分，不像你的JavaScript那样有那么多限制。</p>
<ul>
<li>当需要进行复杂计算时，首先查看Math对象。</li>
<li>另一个例子时选择器API，可以像使用css选择器那样查询DOM文档。css查询被JavaScript原生实现并通过jQuery这个JavaScript库推广开来。Jquery引擎被认为是最快的css查询引擎，但它仍然比原生方法慢。原生的querySelector(),querySelectorAll()方法完成它们的任务时，平均只需要基于JavaScript的css查询的10%的时间。大多数JavaScript库已经使用了原生函数以提高它们的整体性能。</li>
<li>当原生方法可用时，尽量使用它们，尤其时数学运算和DOM操作。用编译后的代码做越多的事情，你的代码就会越快。</li>
</ul>
<h4 id="-">总结</h4>
</li>
<li><p>通过避免使用eval和Function构造器避免二次评估。此外，给setTimeout和setInterval传递函数参数而不是字符串。</p>
</li>
<li>创建新对象和数组时使用对象直接量和数组直接量。它们比非直接量形式创建和初始化更快。</li>
<li>避免重复进行相同工作。当需要检查浏览器时，使用延迟加载或条件预加载。</li>
<li>当执行数学运算时，考虑使用位操作，它直接在数字底层进行操作。</li>
<li><p>原生方法总比JavaScript写的东西要快。尽量使用原生方法。</p>
<h2 id="-">创建并运行部署高性能站点</h2>
</li>
<li><p>第一个也是最重要的提高网站速度的准则，特别针对那些第一次访问网站的用户，是减少渲染页面所需的HTTP请求的数量。因为合并资源通常能够以相当少的工作为用户赢得最大的潜在利益。</p>
<ul>
<li>一个简单的优化是将某些脚本合并成一个外部JavaScript文件，而不是全部，从而大大降低渲染页面所需HTTP请求的数量。</li>
</ul>
</li>
<li>使用内容投递网络<ul>
<li>内容传递网络（CDN）是按照地理分布的计数器网络，通过以太网负责向最终用户分发内容。使用CDN的重要原因是可靠性，可扩展性，但更重要的是性能。事实上，通过地理位置上最近的位置向客户提供服务，CDN可以极大的减少网络延迟</li>
<li>一些大公司维护它们自己的CDN，但通常使用第三方CDN更经济一些。</li>
<li>切换到CDN通常只需要改变少量代码，并可能极大的提高最终用户响应速度。</li>
</ul>
</li>
</ul>
<h4 id="-">总结</h4>
<ul>
<li>合并JavaScript文件，减少HTTP请求的数量</li>
<li>使用压缩工具处理JavaScript文件</li>
<li>以压缩形式提供JavaScript文件（gzip编码）</li>
<li>通过设置HTTP响应报文头使用JavaScript文件可缓存，通过向文件名附加时间戳解决缓存问题。</li>
<li>使用内容投递网络（CDN）提供JavaScript文件，CDN不仅可以提供性能，它还可以为你管理压缩和缓存。</li>
</ul>
<h2 id="tools-">Tools工具</h2>
<ul>
<li>Profiling 性能分析<ul>
<li>在脚本运行期间定时执行不同函数和操作，找出需要优化的部分。</li>
</ul>
</li>
<li>Network analysis 网络分析<ul>
<li>检查图片，样式表，和脚本的加载过程，汇报它们对整个页面加载和渲染的影响。</li>
</ul>
</li>
<li>JavaScript性能分析<pre><code class="lang-js">       var Timer={
          _data:{},
          start:function(key){
              Timer._data[key]=new Data();
          },
          stop:function(key){
              var time=Timer._data[key];
              if(time){
                  Timer._data[key]=new Data()-time;
              }
          },
          getTime:function(key){
              return Timer._data[key];
          }
      }
</code></pre>
</li>
</ul>
<section>
</body>
</html>